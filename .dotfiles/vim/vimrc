" Author: mt3
" Source: https://mt3.github.com/dotfiles

" TODO {{{
    " when loading vimrc, display errors/conflicts verbosely and also prompt user to hit key to clear the errors
    " have Ack open in vsplit
    " turn off smart double quotes in .vim files
    " on logout call PowerLineClearCache
    " viewdir (located at ~/.vim/view) needs to be cleaned out once in a while due to odd issues/conflicts within vim
    " instead of NERDTree, Tagbar, and Taglist, Ctrlp does what all 3 of those do (and i guess better)
    " when toggling comments, make sure code doesn't start w/ a space, whereas actual comments do
    " make font size in adjacent pane be a smaller size (for help files and Voom, etc.)
    " map <D-w> :q!<CR>
    " smartly fold only on def, class, for loops, etc and not just on indentations
    " always open macvim with split pane with the vim help file or whatever info pane (2/3 file, 1/3 help) <C-w> T moves current pane to its own tab. <C-w> 20 < shrinks width of the pane by 20.
    " display errors to logfile or logbuffer, mostly whenever we reload/source .vimrc
    " a line with a todo should have darkened background for the rest of the line after the todo
    " get rid of string highlights in vim files while in the body of a comment such as "this"
        " (check ':set comments?' for what this ftype is using)
        " ':set comments' for c++ file is 'comments=sO:* -,mO:*  ,exO:*/,s1:/*,mb:*,ex:*/,://'. for vim files it is 'comments=sO:" -,mO:"  ,eO:"",:"'
        " thus should be written as ':set comments=sO:" -,mO:"  ,eO:"",:"'
    " change code-folding message so that '32 lines' is a lighter color than the line number
    " .pentadactylrc and .penta files need to be syntax-highlighted using vim (i have an attempt below, but doesn't work)
    " document what many of the non-obvious options do
    " always open new split-panes to the right horizontally, not below/above
    " change color of matching brackets in showmatch option
    " nmap / :h<space> (but why???)
    " make comments a different (non-fixed width) font (helvetica? italicized?)
    " after i do a 'save', automatically change to visual mode
        " map <D-s> :w<CR><ESC>
    " stop infinite scroll at bottom of buffer, go 10 max
    " in split panes, unfocused buffers should be dimmed
    " list all keybindings (':map' lists most of them). list insert and cmd bindings with ':map!'. builtin ones (not user-defined or current ones) can be seen via ':h index'. all options are displayed with':options'. all plugins and bundles that are loaded ':scriptnames'. to list all user-set options type ':set'.
    " set backspace key <BS> to something good:
        " map delete key to delete a whole line! (in normal mode only)
        " nmap <BS> dd<ESC>O
    " have code pasted into vim automatically be indented and formatted properly as per context
    " 'map <leader>uw lowercase' or 'map gu lowercase'
    " map <leader>Uw uppercase or 'map gU lowercase'
    " see vim-sessions: save a workspace/layout, along with tmux settings (see wemux, or vim-mux, etc.)
" }}}


" MAIN STARTUP & LOADING {{{
    """ NOTE: <Cmd-s> in Macvim is <D-s>, not <C-s> or <M-s>!

    set nocompatible " Necesary for fun

    " setup vim plugins using pathogen
    filetype off " need to turn off filetype for pathogen
    " To disable a plugin, add it's bundle name to the following list
    let g:pathogen_disabled = []

    syntax on
    filetype on
    filetype plugin indent on
    let g:is_posix = 1 " vim's default is archaic bourne shell, bring it to the 90s

    if v:version < 703
		echoerr 'WARNING: This vimrc is written for Vim >= v.703; this is' v:version
	endif

    version 7.3
    if &cp | set nocp | endif
    let s:cpo_save=&cpo " 's:' means variable 'cpo_save' has scope defined locally only within this script
    set cpo&vim

    au BufWinLeave * silent! mkview  "make vim save view (state) (folds, cursor, etc)
	au BufWinEnter * silent! loadview "make vim load view (state) (folds, cursor, etc)

    set shell=/usr/local/bin/zsh
    set runtimepath=~/code_and_projects/dotfiles/.dotfiles/vim,$VIMRUNTIME
    set statusline=

	if has("gui_macvim")
        " hold shift key to select text
	    let macvim_hig_shift_movement = 1
	    " implement trackpad gestures
	    nmap <SwipeLeft> gT
	    nmap <SwipeRight> gt
	    " Command-T for CtrlP
        " macmenu &File.New\ Tab key=<D-T>
        " Command-Return for fullscreen
        " macmenu Window.Toggle\ Full\ Screen\ Mode key=<D-CR>
        " Command-Shift-F for Ack
        " map <D-F> :Ack<space>

        " Map Command-# to switch tabs
        " map <D-0> 0gt
        " imap <D-0> <Esc>0gt
        " map <D-1> 1gt
        " imap <D-1> <Esc>1gt
        " map <D-2> 2gt
        " imap <D-2> <Esc>2gt
        " map <D-3> 3gt
        " imap <D-3> <Esc>3gt
        " map <D-4> 4gt
        " imap <D-4> <Esc>4gt
        " map <D-5> 5gt
        " imap <D-5> <Esc>5gt
        " map <D-6> 6gt
        " imap <D-6> <Esc>6gt
        " map <D-7> 7gt
        " imap <D-7> <Esc>7gt
        " map <D-8> 8gt
        " imap <D-8> <Esc>8gt
        " map <D-9> 9gt
        " imap <D-9> <Esc>9gt

        " macmenu &File.Close key=<nop>
        " map <D-w> :CommandW<cr>
        " imap <D-w> <Esc>:CommandW<CR>

        " unbind standard mac keybindings
        " D-t
        " macmenu &File.New\ Tab key=<nop>
        " D-p
        " macmenu &File.Print key=<nop>
        " D-p
        " macmenu Edit.Find.Find\.\.\. key=<nop>
        " D-b
        " macmenu &Tools.Make key=<nop>
        " D-l
        " macmenu &Tools.List\ Errors key=<nop>
    endif

    " if has('mac')
    "     " Use option (alt) as meta key
    "     set macmeta
    " endif

    if v:version >= 703
        " does nothing yet
    endif
" }}}

" LOAD PLUGINS (PATHOGEN) {{{
    source ~/code_and_projects/dotfiles/.dotfiles/vim/bundle/coveragepy/ftplugin/python/coveragepy.vim
    helptags ~/code_and_projects/dotfiles/.dotfiles/vim/bundle/coveragepy/doc
    set rtp+=~/code_and_projects/dotfiles/.dotfiles/vim/bundle/coveragepy

    source ~/code_and_projects/dotfiles/.dotfiles/vim/bundle/jacinto.vim/plugin/jacinto.vim
    set rtp+=~/code_and_projects/dotfiles/.dotfiles/vim/bundle/jacinto.vim
" }}}

" LOAD PLUGINS (VUNDLE) {{{
    filetype on
    filetype off

    " Vundle {{{
        set rtp+=~/code_and_projects/dotfiles/.dotfiles/vim/bundle/vundle/
        call vundle#rc()
        Bundle 'gmarik/vundle'
            " in 'BundleList', you can perform the following:
            "     i/I - installs/updates bundle
            "     D - deletes bundle (be careful not to delete your local modifications)
            "     l - opens log up. Helpful when tracking down errors
            " alias to update plugins
            com! BundleUpdate BundleInstall!
            " TODO com! BundleCleanAndUpdate BundleClean BundleInstall!
            let g:vundle_log=['~/vundle.log']
            " red exclamation mark during 'BundleUpdate' means errors. The symbols mean:
            "     . - entry is up to date
            "     + - entry updated (or installed for the first time)
            "     ! - error(s) occured
            "     - - entry removed
            "     > - currently active entry (along with highlighted cursor line)
            " run ':VundleLog' right after installation finishes and view output in vundle_log

        Bundle 'Rykka/localbundle.vim'
    " }}}

    " Colorschemes {{{
        Bundle 'sjl/badwolf'
        Bundle 'jgallen23/Lucius'
        Bundle 'zachwill/github.vim'
        Bundle 'gregsexton/Gravity'
        Bundle 'baeuml/summerfruit256.vim'
        Bundle 'vim-scripts/ironman.vim'
        Bundle 'altercation/vim-colors-solarized'
        Bundle 'tomasr/molokai'
        Bundle 'nelstrom/vim-mac-classic-theme'
        Bundle 'gmarik/ingretu'
        Bundle 'Rykka/galaxy.vim'
    " }}}

    " Vim Utilities {{{
        " make gvim-only colorschemes work transparently in terminal vim
        Bundle 'godlygeek/csapprox'
        Bundle 'tomtom/tlib_vim'
        Bundle 'tomtom/vimtlib'
        Bundle 'kana/vim-textobj-user'
        Bundle 'kana/vim-textobj-entire'
        Bundle 'vim-scripts/bufkill.vim'
        Bundle 'michaeljsmith/vim-indent-object'
        Bundle 'gmarik/ide-popup.vim'
        Bundle 'h1mesuke/vim-benchmark'
        Bundle 'MarcWeber/vim-addon-mw-utils'
        " Bundle 'mattn/benchvimrc-vim'
        " Vundle/pathogen alternative package manager
        "Bundle 'MarcWeber/vim-addon-manager'

        " vim config debug/sanity checker
        Bundle 'dahu/VimLint'

        " vim unittesting
        Bundle 'mivok/vimcram'

        Bundle 'nathanaelkane/vim-command-w'
            macmenu &File.Close key=<nop>
            nmap <D-w> :CommandW<CR>
            imap <D-w> <Esc>:CommandW<CR>
    " }}}

    " TODO Bundle 'file-line'
    " TODO Bundle 'lastpos.vim'
    " TODO Bundle 'tlib'
    Bundle 'Twinside/vim-hoogle'
    Bundle 'pmorillon/puppet-vim'
    Bundle 'vim-scripts/mathml.vim'
    Bundle 'jeetsukumaran/vim-buffergator'
    " Kills a buffer without closing the split
    Bundle 'vim-scripts/bufkill.vim'
    " Resizes the current buffer to accommodate its content
    Bundle 'roman/golden-ratio'
    Bundle 'ervandew/lookup'
    " Bundle 'ervandew/eclim'
    "Bundle 'ciaranm/detectindent'
    Bundle 'mbbill/VimExplorer'
    Bundle 'mbbill/VimExplorer'
    Bundle 'mattn/webapi-vim'
    Bundle 'troydm/pb.vim'
    Bundle 'troydm/shellasync.vim'
    Bundle 'sanpii/seeks.vim'
    Bundle 'guns/xterm-color-table.vim'
    " Bundle 'tpope/vim-haml'
    Bundle 'tpope/vim-repeat'
    " Vim sugar for the UNIX shell commands
    Bundle 'tpope/vim-eunuch'
    " Bundle 'tpope/rhubarb.vim'
    Bundle 'yesmeck/tips.vim'
    Bundle 'suderman/source.vim'
    Bundle 'pydave/AsyncCommand'
    "Bundle 'megaannum/forms'
    Bundle 'sjl/splice.vim'
    " Bundle 'timcharper/textile.vim'
    " Bundle 'zef/vim-cycle'
    Bundle 'sickill/vim-pasta'
    " Bundle 'rstacruz/sparkup.git', {'rtp': 'vim/'}
    Bundle 'gh:thinca/vim-poslist.git'
    "Bundle 'thinca/vim-ref'
    Bundle 'int3/vim-extradite'
    " Bundle 'thinca/vim-quickrun.git'
    " Bundle 'nelstrom/vim-textobj-rubyblock'
    " Bundle 'gmarik/sudo-gui.vim'
    Bundle 'skibyte/gdb-from-vim'
    "Bundle 'mbadran/headlights'
    Bundle 'dahu/Chroma'
    Bundle 'b4winckler/vim-objc'
    " TODO: this has an error Bundle 'vim-scripts/searchfold.vim'
    Bundle 'chrisbra/unicode.vim'
    Bundle 'chrisbra/improvedft'
    Bundle 'https://github.com/vim-scripts/vmark.vim--Visual-Bookmarking.git'
    Bundle 'greyblake/vim-preview'
    Bundle 'Rykka/mathematic.vim'
    Bundle 'Rykka/colorv.vim'
    Bundle 'Rykka/lastbuf.vim'
    "Bundle 'Twinside/vim-cuteErrorMarker'
    Bundle 'mattn/calendar-vim'
    " Bundle 'embear/vim-longlines'
    " Bundle 'vim-scripts/utl.vim'
    Bundle 'pbrisbin/vim-runfile'
    " Renames the file in the current buffer
    Bundle 'vim-scripts/Rename2'
    Bundle 'dahu/vim-efmc'
    Bundle 'dahu/vim-fanfingtastic'
    Bundle 'dahu/vimple'
    " A better paste
    " Bundle 'sickill/vim-pasta'
    Bundle 'kana/vim-wwwsearch'
    Bundle 'vim-scripts/GoogleReader.vim'
    Bundle 'matthias-guenther/tocdown'

    " Pandoc {{{
        " pandoc syntax file
        Bundle 'vim-scripts/pdc.vim'
        " Bundle 'vim-pandoc/vim-pandoc-extras'
        Bundle 'vim-pandoc/vim-pandoc'
            " let g:pandoc_bibfiles = ['/the/path/to/your/bibtex/file.bib']
    " }}}

    " Bundle 'scrooloose/vim-space'
        " Disables space mappings in select mode to fix snipMate.
        "let g:space_disable_select_mode=1

    Bundle 'tsaleh/vim-align'
        " let g:Align_xstrlen = 3
        " let g:Myalign_def = {
            " \ 'css': ['WP0p1l:', ':\@<=', 'v \v^\s*/\*|\{|\}'],
            " \ 'comma': ['WP0p1l:', ',\@<=', 'g ,'],
            " \ 'colon': ['WP0p1l:', ':\@<=', 'g ,'],
            " \ 'commalist': ['WP0p1l', ',\@<=', 'g ,'],
            " \ 'define': ['WP0p1l:', ' \d\@=', 'g ^#define\s'],
            " \ }

    " Bundle 'doy/vim-foldtext'
        " let g:Foldtext_enable = 1
        " let g:Foldtext_tex_enable = 1
        " let g:Foldtext_cpp_enable = 1
        " let g:Foldtext_perl_enable = 1

    " Bundle 'AndrewRadev/switch.vim'
        " toggle true/false, doublequotes/singlequotes, etc.
        " let g:switch_definitions =
        "     \ [
        "     \   ['foo', 'bar', 'baz']
        "     \ ]

    " IRC & Chat {{{
        Bundle 'ironcamel/vimchat'
            " let g:vimchat_buddylistwidth           = " width of buddy list, default is 30
            " let g:vimchat_logpath                  = " path to store log files, default is ~/.vimchat/logs
            " let g:vimchat_logchats                 = " (0 or 1) default is 1 -- 0 will not log,
            " let g:vimchat_otr                      = " (0 or 1) default is 0 -- enable otr or not
            " let g:vimchat_logotr                   = " (0 or 1) default is 1 -- log otr convos or not
            " let g:vimchat_statusicon               = " (0 or 1) default is 1 -- use a gtk status icon?
            " let g:vimchat_blinktimeout             = " timeout in seconds, default is -1
            " let g:vimchat_buddylistmaxwidth        = " max width of buddy list window, default ''
            " let g:vimchat_timestampformat          = " format of the message timestamp, default "[%H:%M]"
            " let g:vimchat_showPresenceNotification = " notification if buddy changed status, comma-separated list of states, default ""
    " }}}

    " searches and displays information from arbitrary sources like files, buffers, recent files or registers
    Bundle 'Shougo/unite.vim'

    " Translates markup languages into HTML for previewing
    Bundle 'matthias-guenther/hammer.vim'
        " Map Leader + P to preview.
        nmap <Leader>P :Hammer<CR>
        " Set the template.
        let g:HAMMER_TEMPLATE='typographic-light'

    Bundle 'myusuf3/numbers.vim'
        " better line numbers (alternates between relative & absolute line nos.)
        " nnoremap <F3> :NumbersToggle<CR>

    Bundle 'xolox/vim-session'
        " If you only want to save the current tab page:
        set sessionoptions-=tabpages
        " If you don't want help windows to be restored:
        set sessionoptions-=help
        " Don't persist options and mappings because it can corrupt sessions.
        set sessionoptions-=options
        " Always persist Vim's window size.
        set sessionoptions+=resize
        let g:session_directory='~/.vim/sessions'
        " let g:session_autoload='prompt'

    " Mutt {{{
        Bundle 'chrisbra/CheckAttach'
    " }}}

    " Marks {{{
        " vim-signature is apparently better than vim-showmarks and mark-tools
        "Bundle 'kshenoy/vim-signature' TODO has error at startup
         Bundle 'vim-scripts/mark_tools'
         " Show marks in a gutter
        " Bundle 'vim-scripts/ShowMarks7'

         Bundle 'zakj/vim-showmarks'
		    " let showmarks_include = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
		    " " Don't leave on by default, use :ShowMarksOn to enable
		    " let g:showmarks_enable = 0
		    " to only include marks 'abcdefzxABHJio', in that order:
            " let g:showmarks_include="abcdefzxABJio"
            " To override this for a particular buffer with 'ABCDhj.'^':
            " let b:showmarks_include="abcdefzxABJio"
		    " " For marks a-z
		    " highlight ShowMarksHLl gui=bold guibg=LightBlue guifg=Blue
		    " " For marks A-Z
		    " highlight ShowMarksHLu gui=bold guibg=LightRed guifg=DarkRed
		    " " For all other marks
		    " highlight ShowMarksHLo gui=bold guibg=LightYellow guifg=DarkYellow
		    " " For multiple marks on the same line.
		    " highlight ShowMarksHLm gui=bold guibg=LightGreen guifg=DarkGreen
		    hi! link ShowMarksHLl LineNr
            hi! link ShowMarksHLu LineNr
            hi! link ShowMarksHLo LineNr
            hi! link ShowMarksHLm LineNr
    " }}}

    Bundle 'ervandew/supertab'
        let g:SuperTabMappingTabLiteral="<Tab>"
        " let g:SuperTabDefaultCompletionType = "<C-X><C-O>"
        let g:SuperTabDefaultCompletionType = 'context'
        let g:SuperTabContextDefaultCompletionType = '<c-n>'
        let g:SuperTabLongestEnhanced = 1
        " let g:SuperTabMappingForward = "<C-space>"
        let g:SuperTabNoCompleteAfter = ['^', '\s', '\t']
        let g:SuperTabLongestHighlight  = 1 " preselect 1st entry
        let g:SuperTabMidWordCompletion = 0 " TODO explain

    Bundle 'vim-scripts/VOoM'
        " performs code-folding and outlining of markdown, rst, etc.
        let g:voom_tree_placement = 'right'
        let g:voom_tree_width = 35
        let g:voom_default_mode = 'rest'
        let g:voom_return_key = '<Return>'
        let g:voom_tab_key = '<C-Tab>'
        " au Filetype voomtree setlocal norelativenumber nonumber
        " au Filetype voomtree setlocal <buffer> guifont=Droid\ Sans\ Mono\ for\ Powerline:h13.3
        " TODO auto close voom buffer when user hits enter

    Bundle 'Bogdanp/quicksilver.vim'
        nmap <leader>r <Plug>ActivateQS
        let g:QSMatchFn = "fuzzy"
        let g:QSIgnore = "\\.pyc$;\\.swp$"

    Bundle 'bkad/CamelCaseMotion'
        nmap <silent> W <Plug>CamelCaseMotion_w
        xmap <silent> W <Plug>CamelCaseMotion_w
        nmap <silent> B <Plug>CamelCaseMotion_b
        xmap <silent> W <Plug>CamelCaseMotion_b

    Bundle 'mileszs/ack.vim'
        " let g:ackprg="ack-grep -H --nocolor --nogroup --column"
        " let g:ackprg="ack -H --nocolor --nogroup --column"
        " use ggreer/the_silver_searcher since it is faster than Ack
        let g:ackprg = 'ag --nogroup --nocolor --column'
        " Command-Shift-F on MacOS
        map <D-F> :Ack<space>
        nmap <leader>a <Esc>:Ack!<space>

    " Pomodoro {{{
        " Vomodoro isn't a timer, just a visualizer of completed pomodoros
        Bundle 'gregsexton/Vomodoro'

        Bundle 'mnick/vim-pomodoro'
            " Duration of a pomodoro in minutes (default: 25)
            let g:pomodoro_time_work = 25
            " Duration of a break in minutes (default: 5)
            let g:pomodoro_time_slack = 5
            " Log completed pomodoros, 0 = False, 1 = True (default: 0)
            let g:pomodoro_do_log = 0
            " Path to the pomodoro log file (default: /tmp/pomodoro.log)
            let g:pomodoro_log_file = "~/.pomodoro.log"
            set statusline=%#ErrorMsg#%{PomodoroStatus()}%#StatusLine#
            "let g:pomodoro_notification_cmd = 'zenity --notification --text="Pomodoro finished"'' TODO convert to growl notify
    " }}}

    " Commenting {{{
        " tpope/vim-commentary > NERDCommenter
        Bundle 'tpope/vim-commentary'
            "     'gcc' toggles comments for the current line
            "     'gC{motion}' comments a visually selected region (choose region first)
            "     'gCc' comment the current line even if it has a comment
            " nnoremap // :TComment<CR>
            " vnoremap // :TComment<CR>
            " nunmap gcc
            xmap <Leader>c <Plug>Commentary
            nmap <Leader>c <Plug>Commentary
            nmap <Leader>cc <Plug>CommentaryLine
            xmap gc <Plug>Commentary
            nmap gc :TCommentMaybeInline<CR>
            nmap gcc <Plug>CommentaryLine
            augroup plugin_commentary
                au!
                au FileType htmldjango setlocal commentstring={#\ %s\ #}
                "au FileType htmldjango setlocal commentstring={#\ %s\ #}
                au FileType clojurescript setlocal commentstring=;\ %s
                au FileType puppet setlocal commentstring=#\ %s
                au FileType fish setlocal commentstring=#\ %s
            augroup END

        " Bundle 'scrooloose/nerdcommenter'
            "nmap <leader>cc :NERDComToggleComment
            "xmap <leader>cc :NERDComToggleComment
            "nmap gcc :NERDComToggleComment<CR>
            " nmap <leader>/ :call NERDComment(0, "invert")<cr>
            " vmap <leader>/ :call NERDComment(0, "invert")<cr>
    " }}}

    Bundle 'godlygeek/tabular'
        if exists(":Tabularize")
            nmap <Leader>t= :Tabularize /=<CR>
            vmap <Leader>t= :Tabularize /=<CR>
            " key => value
            nmap <Leader>t> :Tabularize /=><CR>
            vmap <Leader>t> :Tabularize /=><CR>
            " key: value
            nmap <Leader>t: :Tabularize /:\zs<CR>
            vmap <Leader>t: :Tabularize /:\zs<CR>
            "     nmap <Leader>a= :Tabularize /=<CR>
            "     vmap <Leader>a= :Tabularize /=<CR>
            "     nmap <Leader>a: :Tabularize /:<CR>
            "     vmap <Leader>a: :Tabularize /:<CR>
            "     nmap <Leader>a:: :Tabularize /:\zs<CR>
            "     vmap <Leader>a:: :Tabularize /:\zs<CR>
            "     nmap <Leader>a, :Tabularize /,<CR>
            "     vmap <Leader>a, :Tabularize /,<CR>
            "     nmap <Leader>a<Bar> :Tabularize /<Bar><CR>
            "     vmap <Leader>a<Bar> :Tabularize /<Bar><CR>
        endif

    " Bundle 'twe4ked/vim-peepopen'
        " Quit peepopen when vim exits
        "let p:peepopen_quit = 1

    " Syntax Checking {{{
        "Bundle 'tomtom/checksyntax_vim'

        Bundle 'scrooloose/syntastic'
            let g:syntastic_enable_highlighting=1
            let g:syntastic_auto_loc_list=2 " automatically close syntastic error window when no errors
            let g:syntastic_enable_signs=1 " mark syntastic errors
            let g:syntastic_quiet_warnings=0
            let g:syntastic_check_on_open=0		" don't automatically check syntax on open buffers
            " let g:syntastic_python_checker = 'pyflakes'
            let g:syntastic_python_checker_args = '--ignore=E123,E128,E225,E401,E501,E702'
            let g:syntastic_stl_format='[%E{Err: %fe #%e}%B{, }%W{Warn: %fw #%w}]'
            " let g:syntastic_stl_format = '[%E{%e Errors}%B{, }%W{%w Warnings}]'
            let g:syntastic_disabled_filetypes = ['html', 'rst']
    " }}}

    Bundle 'sjl/clam.vim'
        " nnoremap ! :Clam<space>
        " let g:clam_autoreturn = 1

    Bundle 'sjl/gundo.vim'
        " nnoremap <Leader>g :GundoToggle<CR>
        " let g:autotagVerbosityLevel=0

    " Yank {{{
        " Bundle 'vim-scripts/YankRing.vim'
        Bundle 'chrismetcalf/vim-yankring'
            nnoremap <silent> <F3> :YRShow<cr>
            inoremap <silent> <F3> <ESC>:YRShow<cr>
            "map <leader>yr :YRShow<cr>
            "let g:yankring_history_dir = '~/code_and_projects/dotfiles/.dotfiles/vim/tmp'
            "nnoremap <Leader>y :YRShow<CR>
            "nmap <leader>r :YRShow<CR>
            "nmap <silent> <Leader>y :YRShow<CR>		" Toggle YankRing.
            "let g:yankring_enabled = 1 			" Enable the yankring.
            "let g:yankring_max_history = 128		" Number of items to save.
            "let g:yankring_share_between_instances = 1	" Reuse the ring.
            "let g:yankring_window_auto_close = 1		" Close YR after action.
            "let g:yankring_window_use_horiz = 1		" Use horizontal split
            "let g:yankring_window_height = 10		" The window heigth.
            "let g:yankring_window_use_bottom = 1		" Split to bottom.
            "let g:yankring_manage_numbered_reg = 1		" Still update the default registers.
            "let g:yankring_history_dir = '~/.vim/'		" Where to put the yankfile.
            "let g:yankring_history_file = 'yankring'	" Filename of the yankfile.
            "let g:yankring_default_menu_mode = 3		" Let alt+y activate the menu.
            "let g:yankring_paste_using_g = 0		" Don't remap gp and gP.
            "let g:yankring_replace_n_pkey = "[p"		" Cycle backwards in yankring on paste.
            "let g:yankring_replace_n_nkey = "]p"		" Cycle forwards in yankring on paste.
	" }}}

    " Quotes & Parens Completion {{{
        "Bundle 'mirell/vim-matchit'
            ":runtime macros/matchit.vim
        "Bundle 'vim-scripts/simple-pairs.git'
        " Bundle 'roman/rainbow.git'
        " Bundle 'vim-scripts/Rainbow-Parenthesis'

        "Bundle 'tpope/vim-surround'
            "let g:surround_{char2nr('-')} = "<% \r %>"
            "let g:surround_{char2nr('=')} = "<%= \r %>"
            "let g:surround_{char2nr('8')} = "/* \r */"
            "let g:surround_{char2nr('s')} = " \r"
            "let g:surround_{char2nr('^')} = "/^\r$/"
            "let g:surround_indent = 1

        " intelligent quotes+parens completion
        Bundle 'Raimondi/delimitMate'
    " }}}

    " Directories, Trees, & Finder {{{
        " ctrlp replaces command-t, NERDTree, buffer, mru (most recent used), tagfinder...
        Bundle 'kien/ctrlp.vim'
        Bundle 'sgur/ctrlp-extensions.vim'
            let g:ctrlp_map = '<c-p>'
            let g:ctrlp_cmd = 'CtrlP' " Default command used for the default mapping
            let g:ctrlp_max_height = 20
            " number of recently opened files for CtrlP to remember
            let g:ctrlp_mruf_max = 250
            let g:ctrlp_mruf_exclude = '/tmp/.*\|/temp/.*'
            " Go up the file system until '.git', or similar, is found.
            let g:ctrlp_working_path_mode = 2
            " Use '.git' as a marker, whether it's a directory or a file (submodule).
            let g:ctrlp_root_markers = ['.git']
            " Do not remember the last input.
            let g:ctrlp_persistent_input = 0
            " Update results after typing has stopped.
            let g:ctrlp_lazy_update = 1
            " Enable help tag, exuberant ctags, quickfix, and directory search.
            let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'dir']
            " Where to put the new tab page when opening one:
            "     a - after.
            "     b - before.
            "     c - the current tab page.
            "     l - the last tab page.
            "     f - the first tab page.
            let g:ctrlp_tabpage_position = 'ac'

            " from sjl's vimrc
            let g:ctrlp_dont_split = 'NERD_tree_2'
            " let g:ctrlp_jump_to_buffer = 0
            " let g:ctrlp_map = '<leader>,'
            " let g:ctrlp_match_window_reversed = 1
            " let g:ctrlp_split_window = 0
            " let g:ctrlp_prompt_mappings = {
            "     \ 'PrtSelectMove("j")': ['<c-j>', '<down>', '<s-tab>'],
            "     \ 'PrtSelectMove("k")': ['<c-k>', '<up>', '<tab>'],
            "     \ 'PrtHistory(-1)': ['<c-n>'],
            "     \ 'PrtHistory(1)': ['<c-p>'],
            "     \ 'ToggleFocus()': ['<c-tab>'],
            "     \ }
            " let ctrlp_filter_greps = "".
            "     \ "egrep -iv '\\.(" .
            "     \ "jar|class|swp|swo|log|so|o|pyc|jpe?g|png|gif|mo|po" .
            "     \ ")$' | " .
            "     \ "egrep -v '^(\\./)?(" .
            "     \ "deploy/|lib/|classes/|libs/|deploy/vendor/|.git/|.hg/|.svn/|.*migrations/|docs/build/" .
            "     \ ")'"
            " let my_ctrlp_user_command = "" .
            "     \ "find %s '(' -type f -or -type l ')' -maxdepth 15 -not -path '*/\\.*/*' | " .
            "     \ ctrlp_filter_greps
            " let my_ctrlp_git_command = "" .
            "     \ "cd %s && git ls-files --exclude-standard -co | " .
            "     \ ctrlp_filter_greps
            " let my_ctrlp_ffind_command = "ffind --semi-restricted --dir %s --type e -B -f"
            " let g:ctrlp_user_command = ['.git/', my_ctrlp_ffind_command, my_ctrlp_ffind_command]
            " nnoremap <leader>. :CtrlPTag<cr>

            " Map buffer search.
            " nnoremap <Leader>b :CtrlPBuffer<CR>
            " Map most recently used file search.
            " nnoremap <Leader>m :CtrlPMRU<CR>
            " Map clear cache.
            " nnoremap <Leader>c :CtrlPClearCache<CR>

            " TODO open ctrlp in vertical split
            "au BufWinEnter *.txt if &ft == 'CtrlP' | wincmd L | endif

            " let g:ctrlp_custom_ignore = '\v[\/](\.git|\.hg|\.svn)$'
            " let g:ctrlp_custom_ignore = {
            "   \ 'dir':  '\v[\/](\.git|\.hg|\.svn)$',
            "   \ 'file': '\.exe$\|\.so$\|\.dll$',
            "   \ 'link': 'some_bad_symbolic_links',
            "   \ }
            " Optional extensions. Order of items will be order they appear on statusline
            " let g:ctrlp_extensions = [
            " \ 'tag', 'buffertag', 'dir', 'rtscript',
            " \ 'undo', 'changes', 'line', 'quickfix',
            " \ 'bookmarkdir', 'mark', 'register'
            " \ ]
            " let my_ctrlp_user_command = "" .
                "\ "find %s '(' -type f -or -type l ')' -maxdepth 15 -not -path '*/\\.*/*' | " .
                "\ ctrlp_filter_greps
            "let my_ctrlp_git_command = "" .
                "\ "cd %s && git ls-files | " .
                "\ ctrlp_filter_greps
            "let g:ctrlp_user_command = ['.git/', my_ctrlp_git_command, my_ctrlp_user_command]
            "let g:loaded_ctrlp = 1         Use this to disable the plugin completely: >
            " |ctrlp_by_filename|           Default to filename mode or not.
            " |ctrlp_regexp|                Default to regexp mode or not.
            " |ctrlp_match_window_bottom|   Where to show the match window.
            " |ctrlp_match_window_reversed| Sort order in the match window.
            " |ctrlp_max_height|            Max height of the match window.
            " |ctrlp_switch_buffer|         Jump to an open buffer if already opened.
            " |ctrlp_reuse_window|          Reuse special windows (help, quickfix, etc).
            " |ctrlp_tabpage_position|      Where to put the new tab page.
            " |ctrlp_working_path_mode|     How to set CtrlP's local working directory.
            " |ctrlp_root_markers|          Additional, high priority root markers.
            " |ctrlp_use_caching|           Use per-session caching or not.
            " |ctrlp_clear_cache_on_exit|   Keep cache after exiting Vim or not.
            " |ctrlp_cache_dir|             Location of the cache directory.
            " |ctrlp_dotfiles|              Ignore dotfiles and dotdirs or not.
            " |ctrlp_custom_ignore|         Hide stuff when using |globpath()|.
            " |ctrlp_max_files|             Number of files to scan initially.
            " |ctrlp_max_depth|             Directory depth to recurse into when scanning.
            " |ctrlp_user_command|          Use an external scanner.
            " |ctrlp_max_history|           Number of entries saved in the prompt history.
            " |ctrlp_open_new_file|         How to open a file created by <c-y>.
            " |ctrlp_open_multiple_files|   How to open files selected by <c-z>.
            " |ctrlp_arg_map|               Intercept <c-y> and <c-o> or not.
            " |ctrlp_follow_symlinks|       Follow symbolic links or not.
            " |ctrlp_lazy_update|           Only update when typing has stopped.
            " |ctrlp_default_input|         Seed the prompt with an initial string.
            " |ctrlp_use_migemo|            Use Migemo patterns for Japanese filenames.
            " |ctrlp_prompt_mappings|       Change the mappings in the prompt.
            " MRU mode:
            " |ctrlp_mruf_max|              Max MRU entries to remember.
            " |ctrlp_mruf_exclude|          Files that shouldn't be remembered.
            " |ctrlp_mruf_include|          Files to be remembered.
            " |ctrlp_mruf_relative|         Show only MRU files in the working directory.
            " |ctrlp_mruf_default_order|    Disable sorting.
            " |ctrlp_mruf_case_sensitive|   MRU files are case sensitive or not.
            " Advanced options:
            " |ctrlp_open_func|             Use custom file opening functions.
            " |ctrlp_status_func|           Change CtrlP's two statuslines.
            " |ctrlp_buffer_func|           Call custom functions in the CtrlP buffer.
    " }}}

    Bundle 'lukaszkorecki/vim-GitHubDashBoard'

    Bundle 'github:mattn/gist-vim.git'
        " Send visual selection to gist.github.com as private, filetyped gist (Requires gist cli 'brew install gist')
        " vnoremap <leader>G :w !gist -p -t %:e \| pbcopy<cr>
        let g:gist_clip_command = 'pbcopy'
        let g:gist_detect_filetype = 1
        let g:gist_open_browser_after_post = 1
        let g:gist_show_privates = 1 " TODO describe
        let g:github_token = $GITHUB_TOKEN

    " Tags {{{
        if executable('ctags')
            " TODO find out which is best
            set tags=~/.ctags,~/.tags,./.tags;
            Bundle 'abudden/TagHighlight'
            Bundle 'malkomalko/vim-librarian.vim'
            " Bundle 'ervandew/taglisttoo'
            " Bundle 'https://bitbucket.org:madevgeny/yate.git'

            Bundle 'majutsushi/tagbar'
                nmap <silent> <F7> :TagbarToggle<CR>
                let g:tagbar_left        = 0		" Keep the window on the right side.
                let g:tagbar_width       = 40		" Width of window.
                let g:tagbar_autoclose   = 1		" Close tagbar when jumping to a tag.
                let g:tagbar_autofocus   = 1		" Give tagbar focus when it's opened.
                let g:tagbar_sort        = 1		" Sort tags alphabetically.
                let g:tagbar_compact     = 1		" Omit the help text.
                let g:tagbar_singleclick = 1		" Jump to tag with a single click.
                let g:tagbar_autoshowtag = 1		" Open folds if tag is not visible.
                " open tagbar on startup
                " autocmd VimEnter * nested :call tagbar#autoopen(1)

            " Bundle 'vim-scripts/taglist.vim'
                "map <F4> :TlistToggle<cr>
                " set location(s) of tags folders
                "set tags+=$HOME/.vim/tags/python.ctags
                " let Tlist_Ctags_Cmd               = "/usr/local/bin/ctags"
                " let Tlist_WinWidth                = 55
                " let Tlist_Auto_Open               = 0 " do not auto open taglist window on startup
                " let Tlist_Use_Right_Window        = 1 " show TagList window on the right
                " let Tlist_Exit_OnlyWindow         = 1         " quit when TagList is the last open window
                " let Tlist_GainFocus_On_ToggleOpen = 1 " put focus on the TagList window when it opens
                "let Tlist_Process_File_Always      = 1     " process files in the background, even when the TagList window isn't open
                "let Tlist_Show_One_File            = 1           " only show tags from the current buffer, not all open buffers
                " let Tlist_Inc_Winwidth            = 1            " increase window by 1 when growing
                "let Tlist_Close_On_Select          = 1
                "let Tlist_File_Fold_Auto_Close     = 1
                " let Tlist_Show_One_File           = 1
                " let tlist_vimwiki_settings        = 'wiki;h:headers'
                " let tlist_tex_settings            = 'latex;h:headers'
                " let tlist_wiki_settings           = 'wiki;h:headers'
                " let tlist_diff_settings           = 'diff;f:file'
                " let tlist_git_settings            = 'diff;f:file'
                " let tlist_gitcommit_settings      = 'gitcommit;f:file'
                "
                " use rst2ctags for ctags
                "let Tlist_Ctags_Cmd = '/path/to/rst2ctags --taglist'
                "let tlist_rst_settings = 'rst;s:sections;i:images'
                "
                "nmap <leader>t :TlistToggle<CR>
                " build tags for current directory
                " map <F8> :!/usr/bin/ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .<CR>
                " auto update ctags when file is written
                " function! UPDATE_TAGS()
                "     let _f_ = expand("%:p")
                "     let _cmd_ = '"ctags -a -f /dvr/tags --c++-kinds=+p --fields=+iaS --extra=+q " ' . '"' . _f_ . '"'
                "     let _resp = system(_cmd_)
                "     unlet _cmd_
                "     unlet _f_
                "     unlet _resp
                " endfunction
                " autocmd BufWritePost *.cpp,*.h,*.c call UPDATE_TAGS()
        endif
    " }}}

    " Web Design {{{
        Bundle 'cakebaker/scss-syntax.vim'
            au BufRead,BufNewFile *.scss set filetype=scss

        " Updates your status line to show what selector you're in in sass files
        Bundle 'aaronjensen/vim-sass-status'

        " Bundle 'kchmck/vim-coffee-script'
        Bundle 'ap/vim-css-color'
        Bundle 'leshill/vim-json'
        Bundle 'groenewege/vim-less'
        Bundle 'amirh/HTML-AutoCloseTag'
        Bundle 'ChrisYip/Better-CSS-Syntax-for-Vim'
    " }}}

    " tmux {{{
        Bundle 'benmills/vimux'
        Bundle 'julienr/vimux-pyutils'
        Bundle 'erikw/tmux-powerline'

        " vim, iterm2, and tmux
        Bundle 'sjl/vitality.vim'
    " }}}

    " Tex & Bibtex {{{
        " bibtex bindings and info: http://vim-latex.sourceforge.net/documentation/latex-suite.html#bibtex-bindings
        "Bundle 'git://vim-latex.git.sourceforge.net/gitroot/vim-latex/vim-latex'
        "Bundle 'vim-scripts/auctex.vim'
        "Bundle 'vim-scripts/TeX-PDF'
        "Bundle 'tomtom/tbibtools_vim'
        " Bundle 'git://atp-vim.git.sourceforge.net/gitroot/atp-vim/atp-vim'

        "Bundle 'vim-scripts/bib_autocomp.vim'
            "let g:bib_autocomp_entry_mapping = {
               "\ 'misc': ['author', 'title', 'howpublished', 'url']
               "\ }

        Bundle 'LaTeX-Box-Team/LaTeX-Box'
            " '\ll' command compiles .tex file into .pdf
            "let g:Tex_ViewRule_ps = 'Preview'
            let g:Tex_ViewRule_ps = 'Skim'
            let g:Tex_ViewRule_pdf = 'Skim'
            let g:Tex_ViewRule_dvi = 'Skim'
            "let g:Tex_ViewRule_dvi = 'TeXniscope'
            " let g:Tex_DefaultTargetFormat = 'pdf'
            " let g:Tex_MultipleCompileFormat = 'pdf,aux'
            " let g:Tex_TreatMacViewerAsUNIX = 0
            let g:Tex_CompileRule_pdf = 'xelatex --interaction=nonstopmode $*'
            " Command-R will write, compile, and forward search--thanks to
            " http://reference-man.blogspot.com/2011/09/fully-integrated-latex-in-macvim.html
            " preview, switch back to main window
            " map <D-r> :w<cr><leader>ll<leader>ls
            " imap <D-r> <ESC><D-r>
            " let g:Tex_SmartKeyBS = 0
            " let g:Tex_SmartKeyQuote = 0
            " let g:Tex_SmartKeyDot = 0
            " let g:Imap_UsePlaceHolders = 0
            " activate forward searching in Vim
            " map ,r :w<CR>:silent !/Applications/Skim.app/Contents/SharedSupport/displayline <C-r>=line('.')<CR> %<.pdf %<CR>
            " let g:Tex_IgnoredWarnings ='
                " \"Underfull\n".
                " \"Overfull\n".
                " \"specifier changed to\n".
                " \"You have requested\n".
                " \"Missing number, treated as zero.\n".
                " \"There were undefined references\n".
                " \"Citation %.%# undefined\n".
                " \"Marginpar on page %.%# moved\n".
                " \"\oval, \circle, or \line size unavailable\n"'
            " let g:Tex_CompileRule_dvi = 'latex --interaction=nonstopmode $*'
            " let g:Tex_CompileRule_ps = 'dvips -Pwww -o $*.ps $*.dvi'
            " let g:Tex_CompileRule_pspdf = 'ps2pdf $*.ps'
            " let g:Tex_CompileRule_dvipdf = 'dvipdfm $*.dvi'
            " let g:Tex_CompileRule_pdf = 'pdflatex $*'
            " let g:Tex_FormatDependency_ps  = 'dvi,ps'
            " let g:Tex_FormatDependency_pspdf = 'dvi,ps,pspdf'
            " let g:Tex_FormatDependency_dvipdf = 'dvi,dvipdf'
    " }}}

    " restructuredtext {{{
        Bundle 'nvie/vim-rst-tables'
        Bundle 'Rykka/riv.vim'
            " restructuredtext folding/syntax/helpers
            " fold all blank lines except one
            let g:riv_fold_blank=1
            " sections and lists get folded
            let g:riv_fold_level=2
            " no fancy <Tab>, <BS>, <CR>, and <S-Tab> in insert mode
            let g:riv_ignored_imaps = "<Tab>,<S-Tab>,<BS>,<CR>,<S-CR>"
            " and don't override my custom mappings in normal either
            let g:riv_ignored_nmaps = "<Tab>,<S-Tab>,<BS>,<CR>,<S-CR>"
            " Riv uses the following punctuation for titles:     = - ~ " ' ` ,
            "       This can be changed with g:riv_section_levels
            "       Section number seperated by g:riv_fold_section_mark (default is "-")
            "       HTML has 6 levels
            let g:riv_section_levels = "=-+^*~\"'`"
            let g:riv_web_browser = 'firefox'
            let project1 = { 'path': '~/notes',}
            let project2 = { 'path': '~/Dropbox/rst',}
            let g:riv_projects = [project1, project2]
            let g:riv_file_link_style = 2 " sphinx style local file links rather than moinmoin
            let g:riv_todo_levels = ' ,o,X'
            let g:riv_todo_keywords = 'TODO,DONE;FIXME,FIXED;START,PROCESS,STOP'
            " TODO nmap <leader>t1 :RivTitle1<CR>
    " }}}

    Bundle 'Lokaltog/vim-powerline'
        let g:Powerline_symbols = 'fancy'
        let g:Powerline_cache_enabled = 1
        let g:Powerline_theme = 'default'
        " let g:Powerline_theme = 'skwp'
        let g:Powerline_colorscheme = 'default'
        let g:Powerline_dividers_override = ['>>', '>', '<<', '<']
        " let g:Powerline_stl_path_style = 'relative'
        let g:Powerline_stl_path_style = 'short'
        "call Pl#Theme#InsertSegment('ws_marker', 'after', 'lineinfo')	" Indicate traling spaces in current buffer

    Bundle 'Lokaltog/vim-easymotion'
        " All motions are now triggered with <Leader><Leader> by default, e.g. <Leader><Leader>t, <Leader><Leader>gE
        " let g:EasyMotion_leader_key = '<LocalLeader>'
        let g:EasyMotion_leader_key = '<Leader>f'
        " TODO map 'f' to easymotion's command
        " let g:EasyMotion_mapping_f = 'f'
        let g:EasyMotion_do_shade = 1 " 1 = shade text after cursor
        " let g:EasyMotion_keys = ";,.pyfgcrl/aoeuidhtns-'qjkxbmwvz"
        " let g:EasyMotion_mapping_t  = '<Leader>w'

    " Search {{{
        " awk, websearch, regex
        Bundle 'Raimondi/vimregextools'
        Bundle 'tejr/vawk'
        Bundle 'tsibley/viack'
        Bundle 'jeetsukumaran/vim-filesearch'
        Bundle 'henrik/vim-indexed-search'
        " TODO error in loading Bundle 'dahu/SearchParty'

        Bundle 'gmarik/github-search.vim'
            " set where you want to clone resulting github repos to. default is '~/src/:author/:project'
            let g:github_search_path_format = '/Applications/github_dwlds:project'
    " }}}

    " Notetaking Apps {{{
        Bundle 'vim-scripts/vimwiki'
            " let g:vimwiki_list = [{'path': '~/.vimwiki/'}]
            " let g:vimwiki_camel_case = 0
            " let g:vimwiki_hl_cb_checked = 1
            " let g:vimwiki_folding = 0
            " let g:vimwiki_browsers = ['firefox']
            " let g:vimwiki_CJK_length = 1
            " let g:vimwiki_dir_link = 'index'
            " let g:vimwiki_html_header_numbering = 2
            " let g:vimwiki_conceallevel = 2

        " Bundle 'hsitz/VimOrganizer'
        " Bundle 'davidoc/taskpaper.vim'
        " Bundle 'xolox/vim-notes'
        " Bundle 'goerz/SimplenoteCLI'
        " Bundle 'metalelf0/vimt0d0'
        " Bundle 'aaronbieber/quicktask'

        " Bundle 'bencrowder/vimlist'
            "let g:vimlist_dir = "/path/to/your/lists"

        " Bundle 'jceb/vim-orgmode'
            "let g:org_plugins = ['ShowHide', '|', 'Navigator', 'EditStructure', '|', 'Todo', 'Date', 'Misc']
            "let g:org_todo_keywords = ['TODO', '|', 'DONE']
            "let g:org_debug = 1

        " notational velocity on vim (nothing to do with simplenote)
        Bundle 'fmoralesc/vim-pad'
            let g:pad_dir='~/temp-vim-pad'

        Bundle 'mt3/simplenote.vim'
            if filereadable(expand("~/.simplenoterc"))
                " source ~/.simplenoterc
                exec ":source ". $HOME . "/.simplenoterc"
            endif
            let g:SimplenoteVertical=1 " scratch buffer is opened in vsplit
            " let g:SimplenoteFiletype=rst "TODO allow for a config of 'setlocal filetype=rst'
    " }}}

    Bundle 'Shougo/vimfiler'
        let g:vimfiler_as_default_explorer = 1
        let s:is_windows = has('win32') || has('win16')
        if s:is_windows
            " Use trashbox
            let g:unite_kind_file_use_trashbox = 1
        else
            " Like Textmate icons
            let g:vimfiler_tree_leaf_icon = ' '
            let g:vimfiler_tree_opened_icon = '▾'
            let g:vimfiler_tree_closed_icon = '▸'
            let g:vimfiler_file_icon = '-'
            let g:vimfiler_marked_file_icon = '*'
        endif

    " Git {{{
        "Bundle 'thinca/vim-github'
        Bundle 'gregsexton/gitv'
            let g:Gitv_CommitStep = 20
            let g:Gitv_WrapLines = 1 " 1 enables wrap
            " diff colors are green for +, red for -
            highlight diffAdded guifg=#00bf00
            highlight diffRemoved guifg=#bf0000
            "nmap <leader>gv :Gitv --all<cr>
            "nmap <leader>gV :Gitv! --all<cr>
            "vmap <leader>gV :Gitv! --all<cr>
            " cached diff output in a vsplit
            "call Gitv_OpenGitCommand("diff --no-color --cached", 'vnew')
        Bundle 'tpope/vim-git'
        Bundle 'tpope/vim-fugitive'
            " nnoremap <leader>W :Gwrite<CR>
            " nnoremap <leader>C :Gcommit -v<CR>
             nnoremap <leader>S :Gstatus \| 7<CR>
            " inoremap <leader>W <Esc><leader>W
            " inoremap <leader>C <Esc><leader>C
            " inoremap <leader>S <Esc><leader>S
            " nnoremap <leader>gl :Shell git gl -18<cr>:wincmd \|<cr>
            " Hub. view on github.com
            nnoremap <leader>H :Gbrowse<cr>
            vnoremap <leader>H :Gbrowse<cr>
            autocmd BufReadPost fugitive://* set bufhidden=delete " close Fugitive buffers when leaving
    " }}}

    " Bundle 'inkarkat/open-browser.vim'

    " Bundle 'mkitt/browser-refresh.vim'
        " com! ONRRB :au! BufWritePost <buffer> :RRB
        " com! NORRB :au! BufWritePost <buffer>

    Bundle 'tpope/vim-unimpaired'
        " bubble visual selection lines
        vmap <M-j> ]egv
        vmap <M-k> [egv
        " Bubble single lines
        nmap <C-Up> [e
        nmap <C-Down> ]e
        " Bubble multiple lines
        vmap <C-Up> [egv
        vmap <C-Down> ]egv"

    "Bundle 'nathanaelkane/vim-indent-guides'
        " visually display indent guidelines
         "let g:indent_guides_guide_size = 1

    " Bundle 'gmarik/hlmatch.vim'
        " nnoremap # :<C-u>HlmCword<CR>
        " nnoremap <leader># :<C-u>HlmGrepCword<CR>
        " vnoremap # :<C-u>HlmVSel<CR>
        " vnoremap <leader># :<C-u>HlmGrepVSel<CR>
        " nnoremap ## :<C-u>HlmPartCword<CR>
        " nnoremap <leader>## :<C-u>HlmPartGrepCword<CR>
        " vnoremap ## :<C-u>HlmPartVSel<CR>
        " vnoremap <leader>## :<C-u>HlmPartGrepVSel<CR>

    " File & Directory Trees {{{
        Bundle 'h1mesuke/unite-outline'

        " Bundle 'wincent/Command-T.git'
            " let g:CommandTMatchWindowAtTop=1 " show window at top
            " "burke's
            " nnoremap <leader>tv :CommandTFlush<cr>\|:CommandT app/views<cr>
            " nnoremap <leader>tc :CommandTFlush<cr>\|:CommandT app/controllers<cr>
            " nnoremap <leader>tm :CommandTFlush<cr>\|:CommandT app/models<cr>
            " nnoremap <leader>tl :CommandTFlush<cr>\|:CommandT lib<cr>
            " nnoremap <leader>ta :CommandTFlush<cr>\|:CommandT app/assets<cr>
            " nnoremap <leader>tp :CommandTFlush<cr>\|:CommandT public<cr>
            " nnoremap <leader>tr :topleft :vsplit config/routes.rb<cr>
            " nnoremap <leader>tg :topleft :vsplit Gemfile<cr>
            "
            " let g:CommandTMatchWindowReverse = 1
            " nnoremap <Leader>f :call :CommandT<CR>
            " nnoremap <Leader>d :call :CommandTBuffer<CR>
            " nnoremap <Leader>F :call :CommandTFlush\|CommandT<CR>
            "
            " let g:CommandTSearchPath = $HOME . '/Code'
            "let g:CommandTMaxHeight = 15
            "set wildignore+=*.o,*.obj,.git,*.pyc,*.hg,*.svn,*.swp,*.bak,*.class
            "noremap <leader>j :CommandT<cr>
            "noremap <leader>y :CommandTFlush<cr>
            "let g:CommandTMaxFiles=20000
            " vertical split with CommandT
            " nnoremap <leader>v :exec ':vnew \| CommandT'<CR>
            " and without
            " nnoremap <leader>V :vnew<CR>
            "if has("gui_macvim")
            "   macmenu &File.New\ Tab key=<nop>
            "   map <D-t> :CommandT<CR>
            "
            "   let macvim_skip_cmd_opt_movement = 1
                "no   <D-Left>       <Home>
                "no!  <D-Left>       <Home>
                "no   <M-Left>       <C-Left>
                "no!  <M-Left>       <C-Left>

                "no   <D-Right>      <End>
                "no!  <D-Right>      <End>
                "no   <M-Right>      <C-Right>
                "no!  <M-Right>      <C-Right>

                "no   <D-Up>         <C-Home>
                "ino  <D-Up>         <C-Home>
                "imap <M-Up>         <C-o>{

                "no   <D-Down>       <C-End>
                "ino  <D-Down>       <C-End>
                "imap <M-Down>       <C-o>}

                "imap <M-BS>         <C-w>
                "inoremap <D-BS>     <esc>my0c`y
            "endif

        Bundle 'scrooloose/nerdtree'
            " Put focus to the NERD Tree with F3 (tricked by quickly closing it and immediately showing it again, since there is no :NERDTreeFocus command)
            nmap <leader>n :NERDTreeClose<CR>:NERDTreeToggle<CR>
            nmap <leader>m :NERDTreeClose<CR>:NERDTreeFind<CR>
            nmap <leader>N :NERDTreeClose<CR>
            map <leader>n :execute 'NERDTreeToggle ' . getcwd()<CR>
            nmap <leader>nt :NERDTreeToggle <CR>
            nmap <C-u> :NERDTreeToggle<CR>
            " Store the bookmarks file
            let NERDTreeBookmarksFile=expand("/code_and_projects/dotfiles/.dotfiles/vim/NERDTreeBookmarks")
            " Show the bookmarks table on startup
            let NERDTreeShowBookmarks=1
            " Set the location of bookmarks for nerdtree
            " autocmd FileType nerdtree setlocal nolist
            " Show hidden files, too
            let NERDTreeShowFiles=1
            let NERDTreeShowHidden=1
            " Don't display these kinds of files
            let NERDTreeIgnore=['\.pyc$', '\.pyo$', '\.py\$class$', '\.obj$', '\.o$', '\.so$', '\.egg$', '^\.git$', '\.swo$', '\.swp$', '\.hg', '\.svn', '\.bzr']
            " open a NERDTree automatically when vim starts even if no files were specified at launch
            autocmd vimenter * if !argc() | NERDTree | endif
            " close vim if nerdtree is last window open
            autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif
            " Quit on opening files from the tree
            "let NERDTreeQuitOnOpen=1
            " Focus cursor in new document TODO after opening from NERDTree?
            "autocmd VimEnter * wincmd p
            " Highlight the selected entry in the tree
            let NERDTreeHighlightCursorline=1
            " Use a single click to fold/unfold directories and a double click to open files
            let NERDTreeMouseMode=2
            "let g:NERDTreeCaseSensitiveSort = 1
            "let g:NERDTreeDirArrows = 1
            let g:NERDTreeMinimalUI = 1
            let g:NERDTreeWinPos = 'right'
            let g:NERDTreeWinSize = 40

        " TODO Bundle 'L9'
        " TODO Bundle 'FuzzyFinder'
            " let g:fuf_modesDisable = []
            " nnoremap <leader>h :FufHelp<CR>
            " nnoremap <leader>2  :FufFileWithCurrentBufferDir<CR>
            " nnoremap <leader>@  :FufFile<CR>
            " nnoremap <leader>3  :FufBuffer<CR>
            " nnoremap <leader>4  :FufDirWithCurrentBufferDir<CR>
            " nnoremap <leader>$  :FufDir<CR>
            " nnoremap <leader>5  :FufChangeList<CR>
            " nnoremap <leader>6  :FufMruFile<CR>
            " nnoremap <leader>7  :FufLine<CR>
            " nnoremap <leader>9  :FufTaggedFile<CR>
            " nnoremap <leader>p :FufDir ~/src/<CR>
            " nnoremap <leader>ge :FufDir ~/.rvm/gems/<CR>
            " nnoremap <leader>gn :vnew \| :FufFile ~/src/notes/<CR>
    " }}}

    Bundle 'vim-scripts/TaskList.vim'
        " displays and organizes TODO, FIXME, etc. within the file
        map <leader>tl <Plug>TaskList
        let g:tlWindowPosition = 1 " 1 opens tasklist at bottom, 0 is top
        " let g:tlTokenList = ['TOKEN1', 'TOKEN2', 'TOKEN3'] " to overwrite list of tokens uncomment, default is let g:tlTokenList = ["FIXME", "TODO", "XXX"]
        let g:tlRememberPosition = 1

    " Snippets & Autocompletion (neocomplcache looks to be the best of them) {{{
        Bundle 'Shougo/neocomplcache-snippets-complete'
        Bundle 'Shougo/neocomplcache'
            " Disable AutoComplPop.
            " let g:acp_enableAtStartup = 0
            let g:neocomplcache_enable_at_startup = 0
            let g:neocomplcache_enable_smart_case = 1
            let g:neocomplcache_enable_camel_case_completion = 1
            let g:neocomplcache_enable_underbar_completion = 1
            " Set minimum syntax keyword length.
            let g:neocomplcache_min_syntax_length = 3
            " let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'
            " let g:neocomplcache_snippets_dir = $HOME . '/snippets'
            " Plugin key-mappings.
            imap <C-k>     <Plug>(neocomplcache_snippets_expand)
            smap <C-k>     <Plug>(neocomplcache_snippets_expand)
            inoremap <expr><C-g>     neocomplcache#undo_completion()
            inoremap <expr><C-l>     neocomplcache#complete_common_string()
            " SuperTab like snippets behavior.
            "imap <expr><TAB> neocomplcache#sources#snippets_complete#expandable() ? "\<Plug>(neocomplcache_snippets_expand)" : pumvisible() ? "\<C-n>" : "\<TAB>"
            " <CR>: close popup and save indent.
            inoremap <expr><CR>  neocomplcache#smart_close_popup() . "\<CR>"
            " <TAB>: completion.
            inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
            " <C-h>, <BS>: close popup and delete backword char.
            inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
            inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
            inoremap <expr><C-y>  neocomplcache#close_popup()
            inoremap <expr><C-e>  neocomplcache#cancel_popup()
            " AutoComplPop like behavior
            "let g:neocomplcache_enable_auto_select = 1
            " Enable omni completion
            autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
            autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
            autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
            autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
            autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
            autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
            " Enable heavy omni completion.
            if !exists('g:neocomplcache_omni_patterns')
              let g:neocomplcache_omni_patterns = {}
            endif
            let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
            let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
            let g:neocomplcache_omni_patterns.c = '\%(\.\|->\)\h\w*'
            let g:neocomplcache_omni_patterns.cpp = '\h\w*\%(\.\|->\)\h\w*\|\h\w*::'

        " garbas & honza's repos are the main snipmate repo. msanders hasn't been updating what he started
        "   one has snipmate, the other has the snippets
        " Bundle 'msanders/snipmate.vim'
        "Bundle 'gmarik/snipmate.vim'
        Bundle 'honza/snipmate.vim'
        Bundle 'rbonvall/snipmate-snippets-bib'
        Bundle 'garbas/snipmate-snippets'
            let g:snips_author = 'mt3'
            let g:snippets_dir = '~/code_and_projects/dotfiles/.dotfiles/vim/bundle/snipmate-snippets'
            "source ~/code_and_projects/dotfiles/.dotfiles/vim/snipmate-snippets/support_functions.vim
            "autocmd vimenter * call s:SetupSnippets()
            "function! s:SetupSnippets()
            "    "if we're in a rails env then read in the rails snippets
            "    if filereadable("./config/environment.rb")
            "        call ExtractSnips("~/.vim/snippets/ruby-rails", "ruby")
            "        call ExtractSnips("~/.vim/snippets/eruby-rails", "eruby")
            "    endif
            "
            "    call ExtractSnips("~/.vim/snippets/html", "eruby")
            "    call ExtractSnips("~/.vim/snippets/html", "xhtml")
            "    call ExtractSnips("~/.vim/snippets/html", "php")
            "endfunction

        " Bundle 'SirVer/ultisnips'
            " let g:UltiSnipsSnippetsDir = '~/.vim/UltiSnips'
            " let g:UltiSnipsExpandTrigger = '<Tab>'
            " let g:UltiSnipsJumpForwardTrigger = '<Tab>'
            " let g:UltiSnipsJumpBackwardTrigger = '<S-Tab>'
            " let g:UltiSnipsExpandTrigger = '<Tab>'
            " let g:UltiSnipsListSnippets = '<S-Tab>'
            " let g:UltiSnipsJumpForwardTrigger = '<C-l>'
            " let g:UltiSnipsJumpBackwardTrigger = '<C-h>'
            " let g:UltiSnipsSnippetDirectories = ['UltiSnips', 'snippets']
    " }}}

    " Python {{{
        " nvie/vim-flake8 supersedes pyflakes-vimand vim-pep8
        "Bundle 'nvie/vim-flake8'
            " to ignore errors from flake8
                " W191: Tabs for indentation
                " E501: Too long line
            " let g:flake8_ignore="E501,W293"

        Bundle 'sunsol/vim_python_fold_compact'
        "Bundle 'Lokaltog/python-syntax'
        "Bundle 'ehamberg/vim-cute-python'
        Bundle 'jmcantrell/vim-virtualenv'
        Bundle 'cwood/pip.vim'
        " Bundle 'cwood/vim-django'

        "Bundle 'klen/python-mode'
            " allows you to use the pylint, rope, pydoc, pyflakes, pep8, mccabe libraries
            " let g:pymode_run = 0
            " let g:pymode_lint = 0
            " Disable pylint checking every save
            "let g:pymode_lint_write = 0
            " Set key 'R' for run python code
            "let g:pymode_run_key = 'R'
            "let g:pymode_doc = 1
            " Key for show python documentation
            "let g:pymode_doc_key = 'K'
            " let g:pymode_breakpoint = 0
            " let g:pymode_utils = 0
            " let g:pymode_utils_whitespaces = 0
            " let g:pymode_syntax = 0
            " let g:pymode_options_indent = 0
            " let g:pymode_options_fold = 0
            " let g:pymode_options_other = 0
            " Load pylint code plugin
            "let g:pymode_lint = 1
            " Switch pylint, pyflakes, pep8, mccabe code-checkers
            "let g:pymode_lint_checker = "pyflakes,pep8,mccabe"
            " Skip errors and warnings
            " E.g. "E501,W002", "E2,W" (Skip all Warnings and Errors startswith E2) and etc
            "let g:pymode_lint_ignore = "E501"
            " Select errors and warnings E.g. "E4,W"
            "let g:pymode_lint_select = ""
            " Run linter on the fly
            "let g:pymode_lint_onfly = 0
            " Pylint configuration file. If file not found use 'pylintrc' from python-mode plugin directory
            "let g:pymode_lint_config = "$HOME/.pylintrc"
            " Check code every save
            "let g:pymode_lint_write = 1
            " Auto open cwindow if errors be finded
            "let g:pymode_lint_cwindow = 1
            " Show error message if cursor placed at the error line
            "let g:pymode_lint_message = 1
            " Auto jump on first error
            "let g:pymode_lint_jump = 0
            " Hold cursor in current window when quickfix is open
            "let g:pymode_lint_hold = 0
            " Place error signs
            "let g:pymode_lint_signs = 1
            " Maximum allowed mccabe complexity
            "let g:pymode_lint_mccabe_complexity = 8
            " Minimal height of pylint error window
            "let g:pymode_lint_minheight = 3
            " Maximal height of pylint error window
            "let g:pymode_lint_maxheight = 6

        "Bundle 'tmhedberg/SimpylFold'
            "let g:SimpylFold_docstring_preview = 1
    " }}}

    " Haskell {{{
        " Bundle 'Twinside/vim-syntax-haskell-cabal'
        " Bundle 'lukerandall/haskellmode-vim'
        " Bundle 'bitc/lushtags'
        " Bundle 'eagletmt/ghcmod-vim'
        " Bundle 'Twinside/vim-syntax-haskell-cabal'
    " }}}

    filetype plugin indent on
" }}}

" OPTIONS, CONFIGURATION, AND SETTINGS {{{
    set noerrorbells
    set visualbell
    set t_vb=
    set guicursor+=a:blinkon0 " turn off goddamned blinking
    set mouse=a " enable mouse in all modes
    set autoread " reload files changed outside vim
    set backspace=indent,eol,start " allow backspacing over everything in insert mode
    set guioptions=egmT
    " set shortmess+=filmnrxoOtT " abbrev. of messages (avoids 'hit enter')
    set guitablabel=%M%t " TODO: other options?
    set tabpagemax=15 " only show 15 tabs
    set helplang=en
    set langmenu=none
    set fileencodings=ucs-bom,utf-8,default,latin1
    set printexpr=system('open\ -a\ Preview\ '.v:fname_in)\ +\ v:shell_error
    set termencoding=utf-8
    " set encoding=utf-8 nobomb " Use UTF-8 without BOM
    set encoding=utf-8
    set fillchars=vert:\ ,fold:_  " characters to use for status line, folds and filler lines (i'm using <space>)
    " set clipboard+=unnamed " Yanks go on clipboard instead
    set scrolloff=2 " keep at least 2 lines above/below
    set sidescrolloff=3 " keep at least 3 lines left/right
    set sidescroll=1 " TODO: document
    set scrolljump=5 " lines to scroll when cursor leaves screen
    set switchbuf=newtab "useopen,usetab " TODO: document
    set nostartofline " when off the cursor is kept in the same column (if possible) and not reset to start of line
    set showmode
    set showcmd " <leader> key appears in right hand corner of vim & disappears after timeout
    set hidden " buffers can be hidden (vim acts like all other editors)
    set report=0 " Always report changes
    set completeopt=menuone,longest,preview
    " set completeopt=longest,menu,menuone
    "               |       |    |
    "               |       |    +-- Show popup even with one match
    "               |       +------- Use popup menu with completions
    "               +--------------- Insert longest completion match
    set wildmenu " Autocomplete features in the status bar. show list instead of just completing
    " set wildmode=list:longest
    set wildmode=list:longest,full	" command <Tab> completion, list matches, then longest common part, then all
    "set wildmode=longest:full,list:full
    "            |            |
    "            |            +-- List matches, complete first match
    "            +--------------- Complete longest prefix, use wildmenu
    set history=200

    set undoreload=1000
    set undolevels=1000
    set complete=.,w,b,u,U,t,i,d  " do lots of scanning on tab completion
    set nobackup " Turn backup off since futurefolks use hg/git/etc.
    set nowb " don't make backup before overwriting file
    "set backupdir=/code_and_projects/dotfiles/.dotfiles/vim/tmp/vim-backup-files
    set noswapfile " this is actually more trouble than it's worth if you keep a swapfile
    " puts swap files in this temp directory rather than all over the fukcing place
    "set directory=/code_and_projects/dotfiles/.dotfiles/vim/tmp/vim-swp-files

    "Persistent undo TODO
    " try
    "     if MySys() == "windows"
    "         set undodir=C:\Windows\Temp
    "     else
    "         set undodir=/code_and_projects/dotfiles/.dotfiles/vim/undo,~/tmp,/tmp
    "     endif
    "     set undofile " keep a permanent undo file
    " catch
    " endtry

    set ttyfast " we have a fast car
    set ttimeoutlen=50 " make Esc work faster
    set timeoutlen=1000 " time to press next key after <Leader> has been pressed before it clears
    set ffs=unix,dos,mac " Default file types
    " Use the same symbols as TextMate for tabstops and EOLs
    "set listchars=tab:▸\ ,eol:¬
    "set listchars=tab:▸\ ,trail:·,extends:#,nbsp:· "TODO
    " set listchars=tab:▸\ ,eol:¬,extends:❯,precedes:❮
    " set showbreak=↪

    " set viminfo='1000,<1000,s100,h
    "             |     |     |    |
    "             |     |     |    +-- Don't restore hlsearch on startup
    "             |     |     +------- Exclude registers greater than N Kb
    "             |     +------------- Keep N lines for each register
    "             +------------------- Keep marks for N files
    " set viminfo=!,'20,<50,s10,h
    " set viminfo='100,f1,h  " save up to 100 marks, enable capital marks, don't restore hlsearch on startup
    set viminfo='100,f1,h " save up to 100 marks, enable capital marks

    let mapleader = ","
    let g:mapleader = ","
    " unmap keymappings
    " nnoremap ,  <Nop>
    " xnoremap ,  <Nop>

    " search settings
    set ignorecase
    set smartcase " Case insensitive searches become sensitive with capitals
    set gdefault " Add the g flag to search/replace by default
    set incsearch
    set showmatch " show matching bracket
    set hlsearch
    " Reset last search query (TODO i believe this is turning off persistent highlighting...)
    let @/ = ""

    filetype on
    filetype indent on
    filetype plugin on
    filetype detect
    syntax enable

    set nowrap
    set whichwrap=b,s,h,l,<,>,[,]	" backspace and cursor keys wrap
    "set shiftround "TODO: use multiple of shiftwidth when indenting with '<' and '>'
    set linebreak    "Wrap lines at convenient points
    set formatoptions=qrn1
    " set formatoptions+=corqn
    "                    |||||
    "                    ||||+-- Recognize numbered lists
    "                    |||+--- Allow formatting of comments with 'gq'
    "                    ||+---- Insert comment leader after <Enter>
    "                    |+----- Insert comment leader after o/O
    "                    +------ Auto-wrap comments
    set display=lastline " when a line is long, do not omit it in @
    " set textwidth=100
    set tabstop=4
    set shiftwidth=4
    set softtabstop=4 " let backspace delete the indent of spaces
    set autoindent
    set copyindent " preserves existing indentation on a new copy
    set cpoptions+=I " TODO maintain indent on a new line after <Esc> is pressed or 'save' file
    set preserveindent " TODO
    set expandtab
    set smarttab " insert tabs on the start of a line according to shiftwidth, not tabstop
    set nopaste " when nopaste is set, it allows for abbreviations, cmaps, etc.
    " set noeol "TODO

    " c formatting and indent options i.e., for non-indent sensitive languages (e.g., python)
    set cinoptions=:s,ps,ts,cs
    set cinwords=if,else,while,do
    set cinwords+=for,switch,case

    set foldenable "fold by default
    set foldmethod=indent " perform code folding based on indentation, 'set foldmethod=marker' detects triple-{ as fold markers
    set foldlevelstart=0 " 0 is start out with everything folded, -1 is no folding
    set foldcolumn=0 " don't have a fold column displayed beside line numbers
    set foldlevel=5 " nested levels above this number are auto-folded
    set foldminlines=0
    set foldnestmax=5 " deepest fold is 5 levels
    set foldopen=block,hor,insert,mark,percent,quickfix,search,tag,undo " commands that trigger auto-unfold

    "let g:is_zsh = 1 " TODO what is this for? from tpope's .vimrc. believe it sets shell to be zsh

    "set t_ce=^V^[[K	" (CTRL-V, <Esc>, [, K) to clear to end of line

    set helpheight=0 " default is 20

    " current directory is always matching the content of the active window
    " set autochdir

    " Smart mappings on the command line TODO: describe
    cno $h e ~/
    cno $d e ~/Downloads/
    cno $j e ./
    cno $c e <C-\>eCurrentFileDir("e")<cr>

    " $q is super useful when browsing on the command line
    cno $q <C-\>eDeleteTillSlash()<cr>
" }}}

" MAPPINGS {{{
    " Navigation {{{
        "remap left/right arrow keys for tab next/previous
        map <Left> gT
        map <Right> gt
        " TODO set <Cmd-S-Left/Right> to move to adjacent tabs when in insert mode as all other mac apps do
        " imap <D-S-Left> gT
        " imap <D-S-Right> gt

        imap <D-BS> 
        imap <M-BS> 
        imap <M-Down> }
        inoremap <D-Down> <C-End>
        imap <M-Up> {
        inoremap <D-Up> <C-Home>
        noremap! <M-Right> <C-Right>
        noremap! <D-Right> <End>
        noremap! <M-Left> <C-Left>
        noremap! <D-Left> <Home>
        map! <D-v> *
        "nmap gx <Plug>NetrwBrowseX
        map <M-Down> }
        noremap <D-Down> <C-End>
        map <M-Up> {
        noremap <D-Up> <C-Home>
        noremap <M-Right> <C-Right>
        noremap <D-Right> <End>
        noremap <M-Left> <C-Left>
        noremap <D-Left> <Home>
        " Easy buffer/split pane navigation
        noremap <C-h>  <C-w>h
        noremap <C-j>  <C-w>j
        noremap <C-k>  <C-w>k
        noremap <C-l>  <C-w>l
        map <C-k> <C-w><Up>
        map <C-j> <C-w><Down>
        map <C-l> <C-w><Right>
        map <C-h> <C-w><Left>
        " vertical window split
        noremap <leader>v <C-w>v
        " Begining & End of line in Normal mode
        noremap H ^
        noremap L g_
        " Use ,z to "focus" the current fold.
        nnoremap <leader>z zMzvzz
    " }}}

    "nnoremap <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cWORD>"),0)

    " Mac-style cut and paste
    vmap <BS> "-d
    vmap <D-x> "*d
    vmap <D-c> "*y
    vmap <D-v> "-d"*P
    " backspace in Visual mode deletes selection
    "vnoremap <BS> d
    nmap <D-v> "*P
    " quickly yank to end of line
    nnoremap Y  y$
    "TODO: another version has nmap Y  y$

    " map delete key to delete a whole line (in normal mode only)
    nmap <BS> dd<ESC>O

    " Split line(opposite to S-J joining line)
    nnoremap <C-J> gEa<CR><ESC>ew

    let &cpo=s:cpo_save
    unlet s:cpo_save

    " allow arrow keys when code completion window is up
    "inoremap <Down> <C-R>=pumvisible() ? "\<lt>C-N>" : "\<lt>Down>"<CR>

    " * and # search for next/previous of selected text when used in visual mode
    " vnoremap * y/<C-R>"<CR>
    " vnoremap # y?<C-R>"<CR>

    " TODO: document
    " if MySys() == "mac"
    "   nmap <D-j> <M-j>
    "   nmap <D-k> <M-k>
    "   vmap <D-j> <M-j>
    "   vmap <D-k> <M-k>
    " endif

    " Tab or Shift-Tab indents/unidents selected line(s)
    " TODO the following vunmaps produce stratup errors
    "vunmap <S-Tab>
    vnoremap <S-Tab> <gv
    "vunmap <Tab>
    vnoremap <Tab>	 >gv
    "nunmap <S-Tab>
    nnoremap <S-Tab> <<
    "nunmap <Tab>
    nnoremap <Tab>	 >>
    " Textmate-style indentation shortcuts
    vnoremap <D-<> <gV
    vnoremap <D->> >gV
    nnoremap <D-<> <<
    nnoremap <D->> >>

    " save file, then goto normal mode TODO: does not work
    " :an 10.290 File.Save <Nop>
	" macm File.Save key=<nop>
    " noremap <D-s> :w<CR>
	"nmap <D-t> :sp .<CR>
    "unmap <D-s>
    "iunmap <D-s> TODO
    "noremap <D-s> :update<CR>
    "inoremap <D-s> :update<CR><Esc>
    "iunmap <D-s> TODO
    imap <D-s> :w<CR><Esc>

    " Fast saving and closing current buffer without closing windows displaying the buffer
    nmap <leader>wq :w!<cr>:Bclose<cr>

    " TODO the below isn't working
    macm File.New\ Tab key=<nop>
    nmap <D-t> :echo "hello " &shell<CR>

    " cd to directory of current file
    map <leader>cd :cd %:p:h<cr>

    map <leader>R :source ~/.vimrc<cr>

    " TODO causes error/crash?
    "nnoremap <leader>hh :exec ':vnew \| help'<CR>
    " TODO all help calls run in a vertical window to the right
    "noremap H :execute "vertical help <cword>"

    " map Enter key to add new line above/below and return to visual mode
    "unmap <CR> TODO
    nmap <CR> o<ESC>0
    "unmap <S-CR> TODO
    nmap <S-CR> O<ESC>0

    " opens current file in a vertical split and switches over
    nnoremap <leader>v <C-w>v<C-w>l

    " Resize vertical windows
    " nmap + <c-w>+
    " nmap _ <c-w>-
    " Resize horizontal windows
    " nmap > <c-w>>
    nmap + <c-w>>
    " nmap < <c-w><
    nmap _ <c-w><

    " Remap j and k to act as expected when used on long, wrapped, lines
    " TODO: relativenumber in column becomes useless if this is enabled
    "nnoremap j gj
    "nnoremap k gk
    " Map the arrow keys to be based on display lines, not physical lines
    map <Down> gj
    map <Up> gk
    " Move cursor together with the screen
    noremap <D-k> j<c-e>
    noremap <D-j> k<c-y>

    " Bubble single lines
    nmap <C-Up> ddkP
    nmap <C-Down> ddp

    " Better Marks
    nnoremap ' `

    " Use Q for formatting instead of Ex mode TODO: explain
    map Q gq

    " Swap ; and :  Convenient. as. fukc.
    nnoremap ; :
    nnoremap : ;

    " space/shift-space scroll in normal mode
    noremap <S-Space> <C-b>
    noremap <Space> <C-f>
    " Saves time (but i already remapped to scrolling a la web browsers below)
    "nmap <Space> ;

    " Swap v and <C-v>  Convenient. as. fukc.
    nnoremap v <C-v>
    nnoremap <C-v> v

    " <S-e> goes to end of line and insert mode with a space
    nmap E $a<SPACE>

    " Bash like keys for the command line
    "cnoremap <C-A>      <Home>
    "cnoremap <C-E>      <End>
    "cnoremap <C-K>      <C-U>

    " Quick alignment of text
    nmap <leader>al :left<CR>
    nmap <leader>ar :right<CR>
    nmap <leader>ac :center<CR>

    map <leader>c :!ctags --recurse<CR>

    " clear highlights
    "nnoremap <S-F3> :set hlsearch!<CR>
    noremap <silent><Leader>h :nohls<CR>
    " nnoremap <cr> :nohlsearch<cr>
    nnoremap <leader>. :nohlsearch<cr>
    " Clear the search buffer when hitting return
    "nnoremap <CR> :nohlsearch<CR>
    "map <leader>h :noh<CR>
    " map <leader>h :set hlsearch!<CR>
    "make <c-l> clear the highlight as well as redraw
    " nnoremap <C-L> :nohls<CR><C-L>
    " inoremap <C-L> <C-O>:nohls<CR>

    " toggle invisibles (whitespace, etc.)
    map <Leader>li :set list!<CR>

    " Close the current buffer
    map <leader>bd :Bclose<cr>

    " hitting jj or kk will jump out of insert mode
    imap jj <Esc>
    " imap kk <Esc>

    " Create Blank Newlines and stay in Normal mode
    nnoremap <silent> zj o<Esc>
    nnoremap <silent> zk O<Esc>

    " yank and put to/from the clipboard register
    " map <Leader>y "*y
    " map <Leader>p "*p
    " toggle paste mode
    " map <Leader>tp :set invpaste<CR>
    " System clipboard interaction. Mostly from:
    " https://github.com/henrik/dotfiles/blob/master/vim/config/mappings.vim
    noremap <leader>y "*y
    noremap <leader>p :set paste<CR>"*p<CR>:set nopaste<CR>
    noremap <leader>P :set paste<CR>"*P<CR>:set nopaste<CR>
    vnoremap <leader>y "*ygv

    "nmap <silent> <leader>h :set invhlsearch<CR>
    "nmap <silent> <leader>l :set invlist<CR>
    "nmap <silent> <leader>n :set invnumber<CR>
    "nmap <silent> <leader>p :set invpaste<CR>
    "nmap <silent> <leader>i :set invrelativenumber<CR>

    " sane regexes: I already know Python regex, why would I want to learn another?
    nnoremap / /\v
    vnoremap / /\v

    " Keep search matches in the middle of the window.
    nnoremap n nzzzv
    nnoremap N Nzzzv
    " nnoremap n nzz
    " nnoremap N Nzz
    " Same when jumping around
    nnoremap g; g;zz
    nnoremap g, g,zz

    " Faster substitute.
    nnoremap <Leader>S :%s//<left>

    " Map Function Keys {{{2
        " commented out the unmap commands since they raised errors due to no map assigned
        " unmap <f1>
        " unmap <f2>
        " unmap <f3>
        map <f3> <Nop>
        map! <f3> <Nop>
        " unmap <f4>
        " unmap <f5>
        "unmap <f6>
        "unmap <f7>
        "unmap <f8>
        "unmap <f9>
        "unmap <f0>
        " toggle/untoggle folds TODO zR is open all folds and zM is close all folds (combine in one keystroke)
        map <f1> zR<Esc>
        map <f2> zM<Esc>
        map <F3> :exe 'echo "yesy"'<CR>
        "map <f3> :exe "echomsg 'yesy'"<CR>
        map <f4> :echo "yesy"<CR>
        " Map F5 to clear the highlighting search
        map <f5> :set hls!<bar>set hls?<CR>
        map <F9> :source $MYVIMRC<CR>:echoe "Vimrc Reloaded!!!"<CR>
        "map <f >
        " autocmd FileType python map <buffer> <F3> :call Flake8()<CR>
    " 2}}}

    " restructuredtext shortcuts {{{
        " Underline the current line with '='
        nmap <silent> <leader>ul :t.\|s/./-/g\|:nohls<cr>
    " }}}

    "py.test mappings
    " Execute the tests
    nmap <silent><Leader>tf <Esc>:Pytest file<CR>
    nmap <silent><Leader>tc <Esc>:Pytest class<CR>
    nmap <silent><Leader>tm <Esc>:Pytest method<CR>
    " cycle through test errors
    nmap <silent><Leader>tn <Esc>:Pytest next<CR>
    nmap <silent><Leader>tp <Esc>:Pytest previous<CR>
    nmap <silent><Leader>te <Esc>:Pytest error<CR>

    " Creating underline/overline headings for markup languages
    " Inspired by http://sphinx.pocoo.org/rest.html#sections
    nnoremap <leader>1 yyPVr=jyypVr=
    nnoremap <leader>2 yyPVr*jyypVr*
    nnoremap <leader>3 yypVr=
    nnoremap <leader>4 yypVr-
    nnoremap <leader>5 yypVr^
    nnoremap <leader>6 yypVr"

    " Code folding options
	" nmap <leader>f0 :set foldlevel=0<CR>
	" nmap <leader>f1 :set foldlevel=1<CR>
	" nmap <leader>f2 :set foldlevel=2<CR>
	" nmap <leader>f3 :set foldlevel=3<CR>
	" nmap <leader>f4 :set foldlevel=4<CR>
	" nmap <leader>f5 :set foldlevel=5<CR>
	" nmap <leader>f6 :set foldlevel=6<CR>
	" nmap <leader>f7 :set foldlevel=7<CR>
	" nmap <leader>f8 :set foldlevel=8<CR>
	" nmap <leader>f9 :set foldlevel=9<CR>

    " Quick editing (pinched from steve losh's .vimrc) {{{
        " nnoremap <leader>ev :vsplit $MYVIMRC<cr>
        " nnoremap <leader>es :vsplit ~/.vim/snippets/<cr>
        " nnoremap <leader>ed :vsplit ~/.vim/custom-dictionary.utf-8.add<cr>
        " nnoremap <leader>eo :vsplit ~/Dropbox/Org<cr>4j
        " nnoremap <leader>eh :vsplit ~/.hgrc<cr>
        " nnoremap <leader>ep :vsplit ~/.pentadactylrc<cr>
        " nnoremap <leader>em :vsplit ~/.mutt/muttrc<cr>
        " nnoremap <leader>ez :vsplit ~/lib/dotfiles/zsh<cr>4j
        " nnoremap <leader>ek :vsplit ~/lib/dotfiles/keymando/keymandorc.rb<cr>
        " nnoremap <leader>et :vsplit ~/.tmux.conf<cr>
    " }}}
" }}}

" FUNCTIONS {{{
    " source .vimrc
    "map <silent> <Leader>s :source ~/.vimrc<CR>:filetype detect<CR>:exe ":echo'vimrc reloaded'"<CR>
    noremap <silent> <Leader>s :source ~/.vimrc<CR>:filetype detect<CR>:exe "echo'vimrc reloaded'"<CR>

    " When vimrc is edited, reload it
    "autocmd! bufwritepost vimrc source ~/.vimrc

    " Edit vimrc \ev
    nnoremap <silent> <Leader>ev :tabedit ~/.vimrc<CR>
    "map <leader>e :e! ~/.vim_runtime/vimrc<cr>
    " Edit gvimrc \gv
    nnoremap <silent> <Leader>gv :tabnew<CR>:e ~/.gvimrc<CR>

    " Merge consecutive empty lines and clean up trailing whitespace
    map <Leader>fm :g/^\s*$/,/\S/-j<Bar>%s/\s\+$//<CR>

    func! s:MySys() " TODO what was this for?
        return "mac"
    endfunc

    " open help in vertical split
    au BufWinEnter *.txt if &ft == 'help' | wincmd L | endif

    func! s:CreateGitStatusSplit()
        Gstatus
        wincmd H
        wincmd L
        <C-w>15<
    endfunc
    command! Gst call s:CreateGitStatusSplit()

    " build ctags taglist for current working directory
    " TODO commented out unmap since errors occured due to no map assignment
    " unmap <F8>
    map <F8> :!/usr/local/bin/ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .<CR>

    function! UpdateTags()
        " update ctags (uses Fugitive?)
        " https://github.com/jmcantrell/dotfiles-vim/blob/master/vimrc
        if exists('b:git_dir')
            let cmd = b:git_dir.'/hooks/ctags'
            if executable(cmd)
                call system(fnameescape(cmd).' &')
            endif
        endif
    endfunction
    autocmd BufWritePost * call UpdateTags()

    " Retab and Strip trailing whitespace
    function! RetabAndStripTrailingWhitespace()
    	:retab!
    	:%s/\s\+$//e
    endfunction
    nnoremap <Leader>cu	:call RetabAndStripTrailingWhitespace()<CR>

    func! DeleteTrailingWhitespace()
        exe "normal mz"
        %s/\s\+$//ge
        exe "normal `z"
    endfunc
    autocmd BufWrite *.py :call DeleteTrailingWhitespace()

    " function! build()
    "    " build the file by running make/gcc
    "    cd /home/arpan/ibm/scripts “go to the folder where Makefile is
    "    make CC=g++
    "    cd /home/sources “back to sources
    "    cl  “list the errors
    " endfunction
    " map <F3> :call build()<CR>

    " For when you forget to sudo... Really Write the file
    " https://github.com/bjeanes/dot-files/blob/master/vim/vimrc
    command! W call s:SudoWrite()
    function! s:SudoWrite()
        write !sudo tee % >/dev/null
        e!
    endfunction

    " Remove duplicates from a list (stolen from pathogen.vim by the one and only Tim Pope)
    function! s:removeduplicates(list) abort
        let i = 0
        let seen = {}
        while i < len(a:list)
            if has_key(seen,a:list[i])
                call remove(a:list,i)
            else
                let seen[a:list[i]] = 1
                let i += 1
            endif
        endwhile
        return a:list
    endfunction

    " func! DeleteTillSlash()
    "   let g:cmd = getcmdline()
    "   if MySys() == "linux" || MySys() == "mac"
    "     let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*", "\\1", "")
    "   else
    "     let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\]\\).*", "\\1", "")
    "   endif
    "   if g:cmd == g:cmd_edited
    "     if MySys() == "linux" || MySys() == "mac"
    "       let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*/", "\\1", "")
    "     else
    "       let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\\]\\).*\[\\\\\]", "\\1", "")
    "     endif
    "   endif
    "   return g:cmd_edited
    " endfunc

    func! CurrentFileDir(cmd)
        return a:cmd . " " . expand("%:p:h") . "/"
    endfunc

    command! Bclose call <SID>BufcloseCloseIt()
    function! <SID>BufcloseCloseIt()
       let l:currentBufNum = bufnr("%")
       let l:alternateBufNum = bufnr("#")

       if buflisted(l:alternateBufNum)
         buffer #
       else
         bnext
       endif

       if bufnr("%") == l:currentBufNum
         new
       endif

       if buflisted(l:currentBufNum)
         execute("bdelete! ".l:currentBufNum)
       endif
    endfunction

    " Specify the behavior when switching between buffers
    try
        set switchbuf=usetab
        set stal=2
    catch
    endtry

    " Run firefox
    "cmap ff :!start "/Applications/BrowserApps/Nightly.app/Contents/MacOS/firefox" "%"<CR>

    "Automatically change current directory to that of the file in the buffer
    autocmd BufEnter * cd %:p:h

    " Source the vimrc right after saving it
    "if has("autocmd")
    "   augroup myvimrchooks
    "       au!
    "       autocmd bufwritepost .vimrc source ~/.vimrc
    "   augroup END
    "endif

    function! SurroundWith(char)
        return AppendLineOf(a:char) . "yykP"
    endf

    " Open URL under cursor in browser (kidnapped from tpope's .vimrc)
    function! OpenURL(url)
        if has("win32")
            exe "!start cmd /cstart /b ".a:url.""
        elseif $DISPLAY !~ '^\w'
            exe "silent !sensible-browser \"".a:url."\""
        else
            exe "silent !sensible-browser -T \"".a:url."\""
        endif
        redraw!
    endfunction
    command! -nargs=1 OpenURL :call OpenURL(<q-args>)
    nnoremap gb :OpenURL <cfile><CR>
    nnoremap gA :OpenURL http://www.answers.com/<cword><CR>
    nnoremap gG :OpenURL https://www.duckduckgo.com/search?q=<cword><CR>
    nnoremap gW :OpenURL http://en.wikipedia.org/wiki/Special:Search?search=<cword><CR>
    " Standard 'go to manual' command
    nmap gm :exe OpenURL('http://google.com/search?q=' . expand("<cword>"))<cr>

    function! CurDir()
        let curdir = substitute(getcwd(), '/Users/linus/', "~/", "g")
        return curdir
    endfunction

    function! HasPaste()
        if &paste
            return 'PASTE MODE  '
        else
            return ''
        endif
    endfunction

    function! BuildAndRunStage()
        " builds and then runs stage app
        " exe '!make && stage myTest.world'
        exe '!ls'
    endf
    " unmap <D-b>
    noremap <D-b> :call BuildAndRunStage()<CR>

    fu! CustomFoldText()
        " custom vim folding
        " http://www.gregsexton.org/2011/03/improving-the-text-displayed-in-a-fold
        " get first non-blank line
        let fs = v:foldstart
        while getline(fs) =~ '^\s*$' | let fs = nextnonblank(fs + 1)
        endwhile
        if fs > v:foldend
            let line = getline(v:foldstart)
        else
            let line = substitute(getline(fs), '\t', repeat(' ', &tabstop), 'g')
        endif
        let w = winwidth(0) - &foldcolumn - (&number ? 8 : 0)
        let foldSize = 1 + v:foldend - v:foldstart
        let foldSizeStr = " " . foldSize . " lines "
        let foldLevelStr = repeat("+--", v:foldlevel)
        let lineCount = line("$")
        let foldPercentage = printf("[%.1f", (foldSize*1.0)/lineCount*100) . "%] "
        let expansionString = repeat(".", w - strwidth(foldSizeStr.line.foldLevelStr.foldPercentage))
        return line . expansionString . foldSizeStr . foldPercentage . foldLevelStr
    endf
    set foldtext=CustomFoldText()

    " from sjl
    " for screenshot: https://gist.github.com/3360978
    " function! MyFoldText() " {{{
        " let line = getline(v:foldstart)

        " let nucolwidth = &fdc + &number * &numberwidth
        " let windowwidth = winwidth(0) - nucolwidth - 3
        " let foldedlinecount = v:foldend - v:foldstart

        " expand tabs into spaces
        " let onetab = strpart(' ', 0, &tabstop)
        " let line = substitute(line, '\t', onetab, 'g')

        " let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
        " let fillcharcount = windowwidth - len(line) - len(foldedlinecount)
        " return line . '…' . repeat(" ",fillcharcount) . foldedlinecount . '…' . ' '
    " endfunction " }}}
    " set foldtext=MyFoldText()

    command! ErrorsToggle call ErrorsToggle()
    function! ErrorsToggle()
        if exists("w:is_error_window")
            unlet w:is_error_window
            exec "q"
        else
            exec "Errors"
            lopen
            let w:is_error_window = 1
        endif
    endfunction
    nmap <silent> <F3> :ErrorsToggle<CR>

    function! BackgroundToggle()
        let &background = ( &background == "dark"? "light" : "dark" )
        if exists("g:colors_name")
            exe "colorscheme " . g:colors_name
        endif
    endfunction
    command! BackgroundToggle :call BackgroundToggle()
    silent! nnoremap <F2> :BackgroundToggle<CR>
    silent! inoremap <F2> :BackgroundToggle<CR>
    silent! vnoremap <F2> :BackgroundToggle<CR>

    " function FoldBrace()
    "   " fold a java/c block to include the function prototype
    "
    "   if getline(v:lnum+1)[0] == '{'
    "     return 1
    "   endif
    "   if getline(v:lnum) =~ '{'
    "     return 1
    "   endif
    "   if getline(v:lnum)[0] =~ '}'
    "     return '<1'
    "   endif
    "   return -1
    " endfunction
" }}}

" APPEARANCE {{{1
    " Set font according to system
    "if MySys() == "mac"
    "    set guifont=Inconsolata-dz\ for\ Powerline:h13
    "    set shell=/usr/local/bin/zsh
    "elseif MySys() == "windows"
    "    set gfn=Bitstream\ Vera\ Sans\ Mono:h10
    "elseif MySys() == "linux"
    "    set gfn=Monospace\ 10
    "    set shell=/bin/bash
    "endif

    set bg=light
    set lazyredraw " do not redraw display while running macros
    set splitright " new vertical split buffers open to the right
    set splitbelow " new horizontal split buffers open at the bottom
    set cursorline
    set nocursorcolumn " turn off highlighting the column which the cursor is in
    " set ruler " show line and column of cursor position
    set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " a ruler on steroids
    set laststatus=2 " 0 means never a statusline even in split-pane mode, 2 always displays one
    set cmdheight=1 " # of screen lines to use for display of cmd line
    set modeline
    set relativenumber

    " replace WinEnter/WinLeave autocmd's to add/remove line numbers in front of each line
    " augroup BgHighlight
        " autocmd!
        " au FocusLost * :set number
        " au FocusGained * :set relativenumber
        " autocmd WinEnter * set relativenumber
        " autocmd WinLeave * set norelativenumber
    " augroup END

    " ignore whitespace in diff mode
    set diffopt+=iwhite

    " STAUTUSLINE settings & options
    " also see http://zfsu709.blogspot.com/2010/07/vim-statusline.html
    " %=     right-aligns anything following it
    " %f     file path
    " %y     file type between braces (if defined)
    " %([%R%M]%)   read-only, modified and modifiable flags between braces
    " %{'!'[&ff=='default_file_format']}
    "        shows a '!' if the file format is not the platform default
    " %{'$'[!&list]}  shows a '*' if in list mode
    " %{'~'[&pm=='']} shows a '~' if in patchmode
    " (%{synIDattr(synID(line('.'),col('.'),0),'name')})
    "        only for debug : display the current syntax item name
    " %=     right-align following items
    " #%n    buffer number
    " %l/%L,%c%V   linenumber, total number of lines, and column number
    " %{} TODO
    " statusline+=%m   " Modified flag.
    " statusline+=%r   " Readonly flag.
    " statusline+=%w   " Preview window flag.
    " statusline+=\    " Space.
    " set statusline+=%h      "help file flag
    " statusline+=%#redbar#                " Highlight the following as a warning.
    " statusline+=%{SyntasticStatuslineFlag()} " Syntastic errors.
    " statusline+=%*                           " Reset highlighting.
    " " File format, encoding and type.  Ex: "(unix/utf-8/python)"
    " set statusline+=(
    " set statusline+=%{&ft}                        " Type (python).
    " set statusline+=)
    " set statusline+=\ (L%l\/%L,\ C%03c)   " Line and column position and counts.
    " set statusline+=\ %{HasPaste()}%F%m%r%h\ %w\ CWD:\ %r%{CurDir()}%h\ \ \ Line:\ %l/%L:%c\
    set statusline+=\ %{HasPaste()}%F%m%r%h\ %w\ \ \ %=%l/%L:%c\ \ %p%%

    "display a warning if &et is wrong, or we have mixed-indenting
    " set statusline+=%#error#
    " set statusline+=%{StatuslineTabWarning()}
    " set statusline+=%*

    " set statusline+=%#warningmsg#
    " set statusline+=%{SyntasticStatuslineFlag()}
    " set statusline+=%*

    if has("gui_running")
        colorscheme lightdark
        " Reload the colorscheme whenever we write the file
        augroup color_lightdark_dev
            au!
            au BufWritePost lightdark.vim color lightdark
        augroup END

        set guifont=Droid\ Sans\ Mono\ for\ Powerline:h13.3
        let s:terminal_italic=1
        " set font=Fanwood:h13
        " set guifont=Inconsolata-dz\ for\ Powerline:h12
        set t_Co=256 " term has 256 colors
        " let color_normal = 'HotPink'
        " let color_insert = 'RoyalBlue1'
        " let color_exit = 'green'
        set linespace=2 " 0 means no extra spaces between rows TODO: what does 2 mean?
        set fuoptions=maxvert,maxhorz
        set fullscreen
        set numberwidth=5 " characters to use for the status line, folds and filler lines
    else
        colorscheme github
        set guifont=Inconsolata-dz\ for\ Powerline:h12
        "if has("xterm-256colors")
            set t_Co=256 " term has 256 colors
        "else
            "set t_Co=16 " remote term has 16 colors for basic reasons
        set linespace=3
        set numberwidth=4
    endif
" }}}

" FILETYPES & LANGUAGES {{{1
    " comments {{{
        " Set comment characters for common languages
        " http://rsontech.net/2009/09/22/comments-revisited.html
        " autocmd FileType python,sh,bash,zsh,ruby,perl let StartComment="#" | let EndComment=""
        " autocmd FileType html let StartComment="<!--" | let EndComment="-->"
        " autocmd FileType php,cpp,javascript let StartComment="//" | let EndComment=""
        " autocmd FileType c,css let StartComment="/*" | let EndComment="*/"
        " autocmd FileType vim let StartComment="\"" | let EndComment=""
        " autocmd FileType ini let StartComment=";" | let EndComment=""
    " }}}

    " nginx {{{
        autocmd BufNewFile,BufRead */etc/nginx/* setlocal ft=nginx
    " }}}

    " Python {{{
        au FileType python runtime! autoload/pythoncomplete.vim
        au FileType python set omnifunc=pythoncomplete#Complete
        let g:SuperTabDefaultCompletionType = "context"
        " au FileType python set guifont=Helvetica:h15:i
        au FileType python highlight Cursor guifg=#cfcfcf
        au FileType python setlocal foldmethod=indent foldlevel=99 foldenable
        au FileType python setlocal foldminlines=10 " TODO: foldminlines?
        au FileType python setlocal nowrap
        au filetype python setlocal expandtab shiftwidth=4 tabstop=4 softtabstop=4 " TODO: expandtab?
        au filetype python setlocal foldtext=substitute(getline(v:foldstart),'\\t','\ \ \ \ ','g')
        au filetype python setlocal textwidth=100
        " display error message if we go beyond 100 chars wide
        au filetype python match ErrorMsg '\%>100v.\+'

        " Add the virtualenv's site-packages to vim path
        "py << EOF
        "import os.path
        "import sys
        "import vim
        "if 'VIRTUAL_ENV' in os.environ:
        "    project_base_dir = os.environ['VIRTUAL_ENV']
        "    sys.path.insert(0, project_base_dir)
        "    activate_this = os.path.join(project_base_dir, 'bin/activate_this.py')
        "    execfile(activate_this, dict(__file__=activate_this))
        "EOF

        let python_highlight_all = 1
        let g:python_show_sync = 1
        let g:python_print_as_function = 1
        let g:pyindent_open_paren = '&sw'
        let g:pyindent_continue = '&sw'

        au FileType python syn keyword pythonDecorator True None False self

        au BufNewFile,BufRead *.jinja set syntax=htmljinja
        au BufNewFile,BufRead *.mako set ft=mako

        "au FileType python inoremap <buffer> $r return
        "au FileType python inoremap <buffer> $i import
        "au FileType python inoremap <buffer> $p print
        "au FileType python inoremap <buffer> $f #--- PH ----------------------------------------------<esc>FP2xi
        "au FileType python map <buffer> <leader>1 /class
        "au FileType python map <buffer> <leader>2 /def
        "au FileType python map <buffer> <leader>C ?class
        "au FileType python map <buffer> <leader>D ?def

        " run a quick static syntax check every time we save a Python file
        " autocmd BufWritePost *.py call Flake8()
    " }}}

    " Help Files {{{
        autocmd FileType help setlocal nonumber	" no line numbers when viewing help
        " autocmd FileType help highlight <buffer> Cursor guibg=Yellow "TODO seems to affect all windows
        au Filetype help nnoremap <buffer> q :bd<CR>
        au Filetype help setl winfixwidth
        au Filetype help setl colorcolumn=
        au Filetype help setl textwidth=65
        au Filetype help setl tabstop=4
        au Filetype help setl expandtab
        au Filetype help setl formatoptions=tcroqwanl1
        " function! s:SetupHelpWindow()
        "     wincmd L
        "     vertical resize 80
        "     nnoremap <buffer> <D-S-Space> <C-]> " Space selects subject
        "     nnoremap <buffer> <BS>    <C-T> " Backspace to go back
        " endfunction
        " TODO function gives errors
        "au BufEnter,BufWinEnter help <buffer> call <SID>SetupHelpWindow()
    " }}}

    " Elasticsearch {{{
        autocmd! BufRead,BufNewFile *.es      setfiletype elasticsearch
    " }}}

    " Pentadactyl {{{
        augroup ft_pentadactyl
            au!
            au BufNewFile,BufRead *.pentadactylrc,pentadactylrc setfiletype pentadactyl
            au BufNewFile,BufRead *.pentadactylrc set ft=pentadactyl
            au BufNewFile,BufRead *.penta setfiletype pentadactyl
            au BufNewFile,BufRead *.penta set ft=pentadactyl
            au BufNewFile,BufRead *.pentadactylrc set foldmethod=marker foldignore=
            au BufNewFile,BufRead *.pentadactylrc  set syntax=pentadactyl
            au FileType pentadactyl set foldmethod=marker
            " au BufNewFile,BufRead ~/Library/Caches/TemporaryItems/pentadactyl-*.tmp set nolist wrap linebreak columns=100 colorcolumn=0
        augroup END
    " }}}

    " Ruby {{{
        au BufNewFile,BufRead *.rb setfiletype ruby
    " }}}

    " Vim {{{
        au BufNewFile,BufRead *.vimrc setfiletype vim
        au BufNewFile,BufRead *.vim setfiletype vim
        au BufNewFile,BufRead vimrc setfiletype vim
        au FileType vim setlocal foldmethod=marker foldignore=
        " let g:vimsyntax_noerror = 1 "TODO
        " au FileType vim set guifont=Helvetica:h15:i
        " au filetype vim match ErrorMsg '\%>100v.\+'
        " augroup vim
            " allow for both marker and manual folding
            " au BufReadPre * setlocal foldmethod=marker
            " au BufWinEnter * if &fdm == 'marker' | setlocal foldmethod=manual | endif
        " augroup END
        augroup ft_vim
        au!
            au FileType vim setlocal foldmethod=marker
            au FileType help setlocal textwidth=78
            au BufWinEnter *.txt if &ft == 'help' | wincmd L | endif
        augroup END
    " }}}

    " RSS {{{
        autocmd BufNewFile,BufRead *.rss setfiletype xml " treat .rss files as XML
    " }}}

    " markdown {{{
        augroup ft_markdown
            autocmd!
            au BufRead,BufNewFile *.{md,mdown,mkd,mkdn,markdown,mdwn}   set filetype=mkd
            " Use <localLeader>1/2/3/4/5/6 to add headings
            autocmd Filetype markdown nnoremap <buffer> <localLeader>1 I# <ESC>
            autocmd Filetype markdown nnoremap <buffer> <localLeader>2 I## <ESC>
            autocmd Filetype markdown nnoremap <buffer> <localLeader>3 I### <ESC>
            autocmd Filetype markdown nnoremap <buffer> <localLeader>4 I#### <ESC>
            autocmd Filetype markdown nnoremap <buffer> <localLeader>5 I##### <ESC>
            autocmd Filetype markdown nnoremap <buffer> <localLeader>6 I###### <ESC>
            " Use <LocalLeader>b to add blockquotes in normal and visual mode
            autocmd Filetype markdown nnoremap <buffer> <localLeader>b I> <ESC>
            autocmd Filetype markdown vnoremap <buffer> <localLeader>b :s/^/> /<CR>
            " Use <localLeader>ul and <localLeader>ol to add list symbols in visual mode
            autocmd Filetype markdown vnoremap <buffer> <localLeader>ul :s/^/* /<CR>
            autocmd Filetype markdown vnoremap <buffer> <LocalLeader>ol :s/^/\=(line(".")-line("'<")+1).'. '/<CR>
            " Use <localLeader>e1/2/3 to add emphasis symbols
            autocmd Filetype markdown nnoremap <buffer> <localLeader>e1 I*<ESC>A*<ESC>
            autocmd Filetype markdown nnoremap <buffer> <localLeader>e2 I**<ESC>A**<ESC>
            autocmd Filetype markdown nnoremap <buffer> <localLeader>e3 I***<ESC>A***<ESC>
            " Use <Leader>P to preview markdown file in browser
            autocmd Filetype markdown nnoremap <buffer> <Leader>P :MarkdownPreview<CR>
        augroup END
    " }}}

    " Git {{{
        autocmd FileType git,gitcommit setlocal foldmethod=syntax foldlevel=1
        autocmd FileType git,gitcommit setlocal textwidth=72
        " gitcommit
        au FileType gitcommit setl colorcolumn=72
        au FileType gitcommit setl formatoptions+=t
        au FileType gitcommit setl formatoptions-=l
        au FileType gitcommit setl textwidth=72
        au FileType gitcommit setl nolist
    " }}}

    " Mail {{{
        " Insert Vim-version as X-Editor in mail headers
        au FileType mail sil 1  | call search("^$") | sil put! ='X-Editor: Vim-' . Version()
    " }}}

    " PBS {{{
        " qsub and pbs cluster scripts
        au BufNewFile,BufRead *.pbs setfiletype zsh
    " }}}

    " Actionscript {{{
        " Treat .as files as Actionscript
        autocmd BufNewFile,BufRead *.as setfiletype actionscript
        autocmd BufNewFile,BufRead *.as set filetype=actionscript
    " }}}

    " Javascript {{{
        au FileType javascript call JavaScriptFold()
        au FileType javascript setl fen
        au FileType javascript setl nocindent

        au FileType javascript imap <c-t> AJS.log();<esc>hi
        au FileType javascript imap <c-a> alert();<esc>hi

        au FileType javascript inoremap <buffer> $r return
        au FileType javascript inoremap <buffer> $f //--- PH ----------------------------------------------<esc>FP2xi

        function! JavaScriptFold()
            setl foldmethod=syntax
            setl foldlevelstart=1
            syn region foldBraces start=/{/ end=/}/ transparent fold keepend extend

            function! JFoldText()
                return substitute(getline(v:foldstart), '{.*', '{...}', '')
            endfunction
            setl foldtext=JFoldText()
        endfunction
    " }}}

    " reStructuredText {{{
        augroup rest
            au!
            au BufNewFile,BufRead *.rst setlocal ft=rest
            au BufNewFile,BufRead *.txt setlocal ft=rst
            " au FileType rst setlocal expandtab shiftwidth=4 tabstop=4 softtabstop=4 formatoptions+=nqt textwidth=74
            au Filetype rst setlocal wrap
            "au Filetype rst setl formatoptions=a TODO error says 'a' is an unknown format option
            " au Filetype rst set foldmethod=syntax foldignore=
            " au FileType rst highlight Type guifg=DarkBlue
            au BufNewFile,BufRead g:voom_default_mode = 'rest'
            " from sjl's vimrc
            au Filetype rst nnoremap <buffer> <localleader>1 yypVr=:redraw<cr>
            au Filetype rst nnoremap <buffer> <localleader>2 yypVr-:redraw<cr>
            au Filetype rst nnoremap <buffer> <localleader>3 yypVr~:redraw<cr>
            au Filetype rst nnoremap <buffer> <localleader>4 yypVr`:redraw<cr>
        augroup END
    " }}}

    " Text {{{
        " autocmd BufRead,BufNewFile {*.txt,*.text} set wrap linebreak spell
        autocmd BufRead,BufNewFile {*.txt,*.text} setlocal wrap linebreak
        " autocmd BufRead,BufNewFile {*.txt,*.text} setlocal <buffer> guifont=Inconsolata-dz:h13
        " auto wrap .txt files to 80 characters
        " autocmd BufRead,BufNewFile *.txt set formatoptions+=t

        " detect text filetype
        " autocmd BufEnter * if &filetype == "" | setlocal ft=txt | endif

        "TODO not working
        " autocmd BufRead,BufNewFile {*.txt,*.text} setlocal hi Todo guifg=Black guibg=#e02020 gui=italic,bold

        " identify txt files with no extensions
        autocmd BufRead README,INSTALL setlocal filetype=txt
    " }}}

    " Textile {{{
        " autocmd BufRead,BufNewFile {*.textile} set wrap linebreak
        autocmd BufRead,BufNewFile {*.textile} setlocal wrap
        autocmd BufRead,BufNewFile {*.textile} setlocal guifont=Inconsolata-dz:h13
        " autocmd BufRead,BufNewFile {*.textile} setlocal hi Todo guifg=Black guibg=#e02020 gui=italic,bold "TODO: not working
    " }}}

    " tmux {{{
        augroup filetypedetect
            au BufNewFile,BufRead .tmux.conf*,tmux.conf* setf tmux
        augroup END
    " }}}

    " YAML {{{
        autocmd FileType yaml setlocal tabstop=4 shiftwidth=4 softtabstop=4
    " }}}

    " Various other settings/configs {{{
        " Strip whitespace on save for all files
        autocmd BufWritePre * :%s/\s\+$//e

        " Remove trailing whitespaces and ^M chars
	    autocmd FileType c,cpp,java,php,js,python,twig,xml,yml autocmd BufWritePre <buffer> :call setline(1,map(getline(1,"$"),'substitute(v:val,"\\s\\+$","","")'))

        au BufRead,BufNewFile *.zsh-theme set ft=zsh

        " Treat JSON files like JavaScript
        au BufNewFile,BufRead *.json set ft=javascript

        " Customisations based on house-style (arbitrary)
        "autocmd FileType html setlocal ts=2 sts=2 sw=2 expandtab
        "autocmd FileType css setlocal ts=2 sts=2 sw=2 expandtab
        "autocmd FileType javascript setlocal ts=4 sts=4 sw=4 noexpandtab

        " Show line number by default for followed filetype
        autocmd FileType html			setlocal number
        autocmd FileType xhtml			setlocal number
        autocmd FileType css,less		setlocal number
        autocmd filetype css,less       setlocal foldmethod=marker foldmarker={,}
        autocmd FileType javascript		setlocal number
        autocmd FileType php			setlocal number
    " }}}
" }}}

" SHELL ALIASES {{{
    com! Pipl :exe '!pipl'<CR> " TODO not reading my zsh aliases
" }}}

" PLUGINS SETUP {{{
    " ConqueShell {{{
        " Enable <C-w> in insert mode
        let g:ConqueTerm_CWInsert = 0
        map <leader>term :ConqueTerm zsh<cr>
        " nmap <F1> :ConqueTermSplit zsh
        " nmap <F2> :ConqueTermVSplit zsh
        " nmap <F3> :ConqueTermSplit ipython
        " nmap <F4> :ConqueTermVSplit ipython
        " nmap <F6> :execute 'ConqueTermSplit ipython '.expand('%:p')
        " nmap <F7> :execute 'ConqueTermVSplit ipython '.expand('%:p')
        " let g:ConqueTerm_EscKey = ''
    " }}}

    " Fugitive {{{
        set statusline+=\
        set statusline+=%#GitStatusLine#
        set statusline+=%{fugitive#statusline()}
        set statusline+=%*
        nmap <leader>g :Ggrep
        nnoremap <silent> <leader>gs :Gstatus<CR>
        nnoremap <silent> <leader>gd :Gdiff<CR>
        nnoremap <silent> <leader>gc :Gcommit<CR>
        nnoremap <silent> <leader>gb :Gblame<CR>
        nnoremap <silent> <leader>gl :Glog<CR>
        nnoremap <silent> <leader>gp :Git push<CR>
    " }}}

    " MinibufExplorer {{{
        "let g:miniBufExplModSelTarget = 1
        "let g:miniBufExplorerMoreThanOne = 0
        "let g:miniBufExplModSelTarget = 0
        "let g:miniBufExplUseSingleClick = 1
        "let g:miniBufExplMapWindowNavVim = 1
        "let g:miniBufExplVSplit = 25
        "let g:miniBufExplSplitBelow=1
        "map <c-w><c-t> :WMToggle<cr>
    " }}}

    " NERDtree-Tabs-Toggle {{{
        map <Leader>n <plug>NERDTreeTabsToggle<CR>
    " }}}

    " Slime {{{
        "let g:slime_target = "tmux" "use tmux instead of screen
    " }}}

    " Syntastic {{{
        set statusline+=%#warningmsg#
        set statusline+=%{SyntasticStatuslineFlag()}
        set statusline+=%*
    " }}}

    " tslime {{{
        let g:tslime_ensure_trailing_newlines = 1
        let g:tslime_normal_mapping = '<localleader>t'
        let g:tslime_visual_mapping = '<localleader>t'
        let g:tslime_vars_mapping = '<localleader>T'
    " }}}

    " vnews (rss feed reader in vim) {{{
        "let g:Vnews#browser_command = "your browser command here" TODO
    " }}}
" }}}

" OTHER ASSORTEDS {{{
    " iPad {{{
        " used for iPad's iSSH app. iOS doesn't allow use of esc key, so makes using vim difficult
        " see http://gilesbowkett.blogspot.com/2011/03/how-to-set-up-vim-to-work-well-via-issh.html
        "if &term == "xterm-ipad"
        "    nnoremap <Tab> <Esc>
        "    vnoremap <Tab> <Esc>gV
        "    onoremap <Tab> <Esc>
        "    inoremap <Tab> <Esc>`^
        "    inoremap <Leader><Tab> <Tab>
        "endif
    " }}}

    " Macvim {{{
         " Create a menu item with title "Newest Window" under the "File" menu, with key equivalent Cmd-k, which opens a new window when selected
         ":an 10.290 File.Newest\ Window <Nop>
         ":macm File.Newest\ Window action=newWindow: key=<D-k>
    " }}}
" }}}

" TEXT EXPANSIONS & ABBREVIATIONS {{{
    iabbrev ggmail firstname.lastname@gmail.com
    iabbrev xdate <C-R>=strftime("%d/%m/%Y %H:%M:%S")<CR>
    iabbrev TDO " TODO
" }}}


" added by oh-my-vim
" let g:ohmyvim="/Library/Frameworks/Python.framework/Versions/2.6/bin/oh-my-vim"
" Use :OhMyVim profiles to list all available profiles
" let profiles = ['defaults']
" load oh-my-vim
" source /Users/mt/.vim/ohmyvim/ohmyvim.vim


" vim: set ft=vim foldmarker={{{,}}} foldmethod=marker:
